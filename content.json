{"meta":{"title":"Jinyu's Blog","subtitle":"金鱼的博客","description":"金鱼的博客","author":"Jin Yu","url":"https://jack838347563.github.io/blog","root":"/blog/"},"pages":[{"title":"about me","date":"2021-05-28T15:35:28.000Z","updated":"2021-05-29T02:30:34.956Z","comments":true,"path":"about/me.html","permalink":"https://jack838347563.github.io/blog/about/me.html","excerpt":"","text":"基本信息 学历:本科 地点:重庆 求职意向 目标职位:web前端工程师 目标城市:杭州、上海、北京、深圳 教育背景 2015.9-至今就读于重庆大学计算机科学与技术专业。 入选卓越工程师计划。2016年至今在软件理论与技术重庆市重点实验室跟随导师进行项目研发，主要方向为web前端。 项目经历 2016.2-2016.4 易班图书馆轻应用 全栈 在易班平台搭建图书馆轻应用。技术选型jquery+amazeui。 2016.6-2017.5 基于图像识别的图书馆座位管理系统 负责人 通过摄像头抓取的图像进行识别判定座位使用情况，包括物联网部分和微信平台。作为负责人统筹策划，在技术方面负责计算机视觉算法以及微信平台前端，微信平台为单页面应用，技术选型为opencv+weui+angularjs。 2016.11-2017.9 学校党务系统 web前端 学校党务信息平台，导师项目。负责移动web前端，技术选型weui+vue。 2017.11至今 toki-hexo主题 负责人 一款hexo博客主题，已被收录，个人开源项目。技术选型sass+gulp+pug。 2018.12至今 网页样式库ponyo 负责人 个人开源项目，用于练习sass和gulp，掌握常见web组件的样式。 2018.2-2018.3 重庆市渝中区静水社工网站 web前端 社工群体官网。负责ui设计和web前端，技术选型amazeui+pug+gulp。 荣誉奖项 ICAN国际创新创业大赛 全国二等奖 中国大学生计算机设计大赛 全国二等奖 全国高校物联网应用创新大赛 西南赛区二等奖 全国大学生软件测试大赛web安全测试 西南赛区三等奖"},{"title":"tags","date":"2021-05-29T02:20:49.000Z","updated":"2021-05-29T02:32:16.075Z","comments":false,"path":"tags/index.html","permalink":"https://jack838347563.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-29T02:21:04.000Z","updated":"2021-05-29T02:21:54.154Z","comments":false,"path":"categories/index.html","permalink":"https://jack838347563.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"visitor","slug":"visitor","date":"2021-05-29T15:30:03.000Z","updated":"2021-05-29T03:04:46.699Z","comments":true,"path":"2021/05/29/visitor/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/visitor/","excerpt":"目的表示要在对象结构的元素上执行的操作。访问者可让你定义新操作，而无需更改其所操作元素的类。 解释真实世界例子 考虑有一个带有军队单位的树形结构。指挥官下有两名中士，每名中士下有三名士兵。基于这个层级结构实现访问者模式，我们可以轻松创建与指挥官，中士，士兵或所有人员互动的新对象 通俗的说 访问者模式定义可以在数据结构的节点上执行的操作。 维基百科说 在面向对象的程序设计和软件工程中，访问者设计模式是一种将算法与操作对象的结构分离的方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作。","text":"目的表示要在对象结构的元素上执行的操作。访问者可让你定义新操作，而无需更改其所操作元素的类。 解释真实世界例子 考虑有一个带有军队单位的树形结构。指挥官下有两名中士，每名中士下有三名士兵。基于这个层级结构实现访问者模式，我们可以轻松创建与指挥官，中士，士兵或所有人员互动的新对象 通俗的说 访问者模式定义可以在数据结构的节点上执行的操作。 维基百科说 在面向对象的程序设计和软件工程中，访问者设计模式是一种将算法与操作对象的结构分离的方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作。 程序示例 使用上面的军队单元的例子，我们首先由单位和单位访问器类型。 123456789101112131415161718192021public abstract class Unit &#123; private final Unit[] children; public Unit(Unit... children) &#123; this.children = children; &#125; public void accept(UnitVisitor visitor) &#123; Arrays.stream(children).forEach(child -&gt; child.accept(visitor)); &#125;&#125;public interface UnitVisitor &#123; void visitSoldier(Soldier soldier); void visitSergeant(Sergeant sergeant); void visitCommander(Commander commander);&#125; 然后我们有具体的单元。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Commander extends Unit &#123; public Commander(Unit... children) &#123; super(children); &#125; @Override public void accept(UnitVisitor visitor) &#123; visitor.visitCommander(this); super.accept(visitor); &#125; @Override public String toString() &#123; return &quot;commander&quot;; &#125;&#125;public class Sergeant extends Unit &#123; public Sergeant(Unit... children) &#123; super(children); &#125; @Override public void accept(UnitVisitor visitor) &#123; visitor.visitSergeant(this); super.accept(visitor); &#125; @Override public String toString() &#123; return &quot;sergeant&quot;; &#125;&#125;public class Soldier extends Unit &#123; public Soldier(Unit... children) &#123; super(children); &#125; @Override public void accept(UnitVisitor visitor) &#123; visitor.visitSoldier(this); super.accept(visitor); &#125; @Override public String toString() &#123; return &quot;soldier&quot;; &#125;&#125; 然后有一些具体的访问者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class CommanderVisitor implements UnitVisitor &#123; private static final Logger LOGGER = LoggerFactory.getLogger(CommanderVisitor.class); @Override public void visitSoldier(Soldier soldier) &#123; // Do nothing &#125; @Override public void visitSergeant(Sergeant sergeant) &#123; // Do nothing &#125; @Override public void visitCommander(Commander commander) &#123; LOGGER.info(&quot;Good to see you &#123;&#125;&quot;, commander); &#125;&#125;public class SergeantVisitor implements UnitVisitor &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SergeantVisitor.class); @Override public void visitSoldier(Soldier soldier) &#123; // Do nothing &#125; @Override public void visitSergeant(Sergeant sergeant) &#123; LOGGER.info(&quot;Hello &#123;&#125;&quot;, sergeant); &#125; @Override public void visitCommander(Commander commander) &#123; // Do nothing &#125;&#125;public class SoldierVisitor implements UnitVisitor &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SoldierVisitor.class); @Override public void visitSoldier(Soldier soldier) &#123; LOGGER.info(&quot;Greetings &#123;&#125;&quot;, soldier); &#125; @Override public void visitSergeant(Sergeant sergeant) &#123; // Do nothing &#125; @Override public void visitCommander(Commander commander) &#123; // Do nothing &#125;&#125; 最后，来看看实践中访问者模式的力量。 123commander.accept(new SoldierVisitor());commander.accept(new SergeantVisitor());commander.accept(new CommanderVisitor()); 程序输出: 123456789Greetings soldierGreetings soldierGreetings soldierGreetings soldierGreetings soldierGreetings soldierHello sergeantHello sergeantGood to see you commander Class diagram 适用性使用访问者模式当 对象结构包含许多具有不同接口的对象类，并且你希望根据这些对象的具体类对这些对象执行操作。 需要对对象结构中的对象执行许多不同且不相关的操作，并且你想避免使用这些操作“污染”它们的类。 访问者可以通过在一个类中定义相关操作来将它们保持在一起。当许多应用程序共享对象结构时，请使用访问者模式将操作仅放在需要它们的那些应用程序中 定义对象结构的类很少变化，但是你经常想在结构上定义新的操作。更改对象结构类需要重新定义所有访问者的接口，这可能会导致成本高昂。如果对象结构类经常更改，则最好在这些类中定义操作。 真实例子 Apache Wicket component tree, see MarkupContainer javax.lang.model.element.AnnotationValue and AnnotationValueVisitor javax.lang.model.element.Element and Element Visitor java.nio.file.FileVisitor https://www.amazon.com/gp/product/0321213351/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321213351&amp;linkCode=as2&amp;tag=javadesignpat-20&amp;linkId=2a76fcb387234bc71b1c61150b3cc3a7)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"参观者模式","slug":"参观者模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%8F%82%E8%A7%82%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"introduce(模式简介)","slug":"introduce","date":"2021-05-29T03:00:17.000Z","updated":"2021-05-29T03:05:28.540Z","comments":true,"path":"2021/05/29/introduce/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/introduce/","excerpt":"设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。","text":"设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"模式简介","slug":"模式简介","permalink":"https://jack838347563.github.io/blog/tags/%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"参观者模式","slug":"参观者模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%8F%82%E8%A7%82%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"模式简介","slug":"模式简介","permalink":"https://jack838347563.github.io/blog/tags/%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"}]}