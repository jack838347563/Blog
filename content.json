{"meta":{"title":"Mr.Yu's Blog","subtitle":"鱼先生的博客","description":"鱼先生的博客","author":"Mr Yu","url":"https://jack838347563.github.io/blog","root":"/blog/"},"pages":[{"title":"categories","date":"2021-05-29T02:21:04.000Z","updated":"2021-05-29T02:21:54.154Z","comments":false,"path":"categories/index.html","permalink":"https://jack838347563.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"about me","date":"2021-05-28T15:35:28.000Z","updated":"2021-05-29T10:43:16.307Z","comments":true,"path":"about/me.html","permalink":"https://jack838347563.github.io/blog/about/me.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;风雨飘摇二十余载，时间如白驹过隙，恍然间已是奔三的年纪了。回顾过去，似乎没有很多特别难忘的记忆，总是试着回想小时候的自己，小时候的人和事，却总是感觉记忆被抹去一般，只留下一堆碎片，拼拼凑凑也只能勉强还原两三件来。或许是过的太平淡？或许是过的太没心没肺？又或许是年龄实在太小脑容量不够？一切的一切似乎随着时间的推移，注定被冲刷，注定随着历史的车轮而被无情的碾压，最终什么也不会留下。因为我们实在渺小，渺小的有些悲情，渺小的有些伤感，甚至渺小的有些不近人情。&nbsp;&nbsp;&nbsp;&nbsp;可人类这个物种，生而倔强，我们不信邪，我们渴望强大，渴望成长，渴望掌控一切。纵使渺小，我们也想书写一个大大的我。我们努力，我们坚强，我们不断挑战自己，战胜自己，提升自己，向着一个个更高的目标而披荆斩棘的奋进着，充满着舍我其谁，唯我独尊的霸气。&nbsp;&nbsp;&nbsp;&nbsp;时常我想象着自己就像漫画《龙珠》中的悟空，不断寻求挑战，不断修炼，不断的想要提升自己的力量，只为自己变得更强。悟空的难能可贵之处也许就在于悟空的心思很单纯，他只是想努力的变得更强，再强一点。他不会因为强大而鄙视小时候一同修炼的玩伴库林，也不会洋洋自得，自视甚高，他真的是在变强的道路上一步一步的前行着，什么都阻挡不了他。而我也时常告诫自己，持之以恒，提升自己；纵使强大，也得保持一颗谦卑的心，心纯净，力量才会更纯粹。生活不会让我们低头，只会让我们挺起骄傲的头颅，在逆境中逆流而上，到达泉源，享受最终的纯净甜美。那时我们回过头，我们可以自豪的微微一笑，顿觉甘之如饴，撑起自信的小舟向更广阔的海洋前进。&nbsp;&nbsp;&nbsp;&nbsp;所以奋进吧，骚年！"},{"title":"tags","date":"2021-05-29T02:20:49.000Z","updated":"2021-05-29T02:32:16.075Z","comments":false,"path":"tags/index.html","permalink":"https://jack838347563.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Visitor(访问者模式)","slug":"visitor","date":"2021-05-29T10:16:12.000Z","updated":"2021-05-29T15:16:26.798Z","comments":true,"path":"2021/05/29/visitor/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/visitor/","excerpt":"目的表示要在对象结构的元素上执行的操作。访问者可让你定义新操作，而无需更改其所操作元素的类。 解释真实世界例子 考虑有一个带有军队单位的树形结构。指挥官下有两名中士，每名中士下有三名士兵。基于这个层级结构实现访问者模式，我们可以轻松创建与指挥官，中士，士兵或所有人员互动的新对象 通俗的说 访问者模式定义可以在数据结构的节点上执行的操作。 维基百科说 在面向对象的程序设计和软件工程中，访问者设计模式是一种将算法与操作对象的结构分离的方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作。","text":"目的表示要在对象结构的元素上执行的操作。访问者可让你定义新操作，而无需更改其所操作元素的类。 解释真实世界例子 考虑有一个带有军队单位的树形结构。指挥官下有两名中士，每名中士下有三名士兵。基于这个层级结构实现访问者模式，我们可以轻松创建与指挥官，中士，士兵或所有人员互动的新对象 通俗的说 访问者模式定义可以在数据结构的节点上执行的操作。 维基百科说 在面向对象的程序设计和软件工程中，访问者设计模式是一种将算法与操作对象的结构分离的方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作。 程序示例 使用上面的军队单元的例子，我们首先由单位和单位访问器类型。 123456789101112131415161718192021public abstract class Unit &#123; private final Unit[] children; public Unit(Unit... children) &#123; this.children = children; &#125; public void accept(UnitVisitor visitor) &#123; Arrays.stream(children).forEach(child -&gt; child.accept(visitor)); &#125;&#125;public interface UnitVisitor &#123; void visitSoldier(Soldier soldier); void visitSergeant(Sergeant sergeant); void visitCommander(Commander commander);&#125; 然后我们有具体的单元。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Commander extends Unit &#123; public Commander(Unit... children) &#123; super(children); &#125; @Override public void accept(UnitVisitor visitor) &#123; visitor.visitCommander(this); super.accept(visitor); &#125; @Override public String toString() &#123; return &quot;commander&quot;; &#125;&#125;public class Sergeant extends Unit &#123; public Sergeant(Unit... children) &#123; super(children); &#125; @Override public void accept(UnitVisitor visitor) &#123; visitor.visitSergeant(this); super.accept(visitor); &#125; @Override public String toString() &#123; return &quot;sergeant&quot;; &#125;&#125;public class Soldier extends Unit &#123; public Soldier(Unit... children) &#123; super(children); &#125; @Override public void accept(UnitVisitor visitor) &#123; visitor.visitSoldier(this); super.accept(visitor); &#125; @Override public String toString() &#123; return &quot;soldier&quot;; &#125;&#125; 然后有一些具体的访问者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class CommanderVisitor implements UnitVisitor &#123; private static final Logger LOGGER = LoggerFactory.getLogger(CommanderVisitor.class); @Override public void visitSoldier(Soldier soldier) &#123; // Do nothing &#125; @Override public void visitSergeant(Sergeant sergeant) &#123; // Do nothing &#125; @Override public void visitCommander(Commander commander) &#123; LOGGER.info(&quot;Good to see you &#123;&#125;&quot;, commander); &#125;&#125;public class SergeantVisitor implements UnitVisitor &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SergeantVisitor.class); @Override public void visitSoldier(Soldier soldier) &#123; // Do nothing &#125; @Override public void visitSergeant(Sergeant sergeant) &#123; LOGGER.info(&quot;Hello &#123;&#125;&quot;, sergeant); &#125; @Override public void visitCommander(Commander commander) &#123; // Do nothing &#125;&#125;public class SoldierVisitor implements UnitVisitor &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SoldierVisitor.class); @Override public void visitSoldier(Soldier soldier) &#123; LOGGER.info(&quot;Greetings &#123;&#125;&quot;, soldier); &#125; @Override public void visitSergeant(Sergeant sergeant) &#123; // Do nothing &#125; @Override public void visitCommander(Commander commander) &#123; // Do nothing &#125;&#125; 最后，来看看实践中访问者模式的力量。 123commander.accept(new SoldierVisitor());commander.accept(new SergeantVisitor());commander.accept(new CommanderVisitor()); 程序输出: 123456789Greetings soldierGreetings soldierGreetings soldierGreetings soldierGreetings soldierGreetings soldierHello sergeantHello sergeantGood to see you commander Class diagram 适用性使用访问者模式当 对象结构包含许多具有不同接口的对象类，并且你希望根据这些对象的具体类对这些对象执行操作。 需要对对象结构中的对象执行许多不同且不相关的操作，并且你想避免使用这些操作“污染”它们的类。 访问者可以通过在一个类中定义相关操作来将它们保持在一起。当许多应用程序共享对象结构时，请使用访问者模式将操作仅放在需要它们的那些应用程序中 定义对象结构的类很少变化，但是你经常想在结构上定义新的操作。更改对象结构类需要重新定义所有访问者的接口，这可能会导致成本高昂。如果对象结构类经常更改，则最好在这些类中定义操作。 真实例子 Apache Wicket component tree, see MarkupContainer javax.lang.model.element.AnnotationValue and AnnotationValueVisitor javax.lang.model.element.Element and Element Visitor java.nio.file.FileVisitor https://www.amazon.com/gp/product/0321213351/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321213351&amp;linkCode=as2&amp;tag=javadesignpat-20&amp;linkId=2a76fcb387234bc71b1c61150b3cc3a7)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Template(模板模式)","slug":"Template","date":"2021-05-29T10:14:25.000Z","updated":"2021-05-29T10:21:48.862Z","comments":true,"path":"2021/05/29/Template/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Template/","excerpt":"目的在一个操作中定义算法的骨架，将某些步骤推迟到子类。模板方法允许子类重新定义算法的某些步骤，而无需更改算法的结构。 解释真实世界例子 偷东西的一般步骤是相同的。 首先，选择目标，然后以某种方式使其迷惑，最后，你偷走了该物品。然而这些步骤有很多实现方式。 通俗的说 模板方法模式在父类中列出一般的步骤然后让具体的子类定义实现细节。 维基百科说 在面向对象的编程中，模板方法是Gamma等人确定的行为设计模式之一。在《设计模式》一书中。模板方法是父类中一个方法，通常是一个抽象父类，根据许多高级步骤定义了操作的骨架。这些步骤本身由与模板方法在同一类中的其他帮助程序方法实现。","text":"目的在一个操作中定义算法的骨架，将某些步骤推迟到子类。模板方法允许子类重新定义算法的某些步骤，而无需更改算法的结构。 解释真实世界例子 偷东西的一般步骤是相同的。 首先，选择目标，然后以某种方式使其迷惑，最后，你偷走了该物品。然而这些步骤有很多实现方式。 通俗的说 模板方法模式在父类中列出一般的步骤然后让具体的子类定义实现细节。 维基百科说 在面向对象的编程中，模板方法是Gamma等人确定的行为设计模式之一。在《设计模式》一书中。模板方法是父类中一个方法，通常是一个抽象父类，根据许多高级步骤定义了操作的骨架。这些步骤本身由与模板方法在同一类中的其他帮助程序方法实现。 编程示例 让我们首先介绍模板方法类及其具体实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public abstract class StealingMethod &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StealingMethod.class); protected abstract String pickTarget(); protected abstract void confuseTarget(String target); protected abstract void stealTheItem(String target); public void steal() &#123; var target = pickTarget(); LOGGER.info(&quot;The target has been chosen as &#123;&#125;.&quot;, target); confuseTarget(target); stealTheItem(target); &#125;&#125;public class SubtleMethod extends StealingMethod &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SubtleMethod.class); @Override protected String pickTarget() &#123; return &quot;shop keeper&quot;; &#125; @Override protected void confuseTarget(String target) &#123; LOGGER.info(&quot;Approach the &#123;&#125; with tears running and hug him!&quot;, target); &#125; @Override protected void stealTheItem(String target) &#123; LOGGER.info(&quot;While in close contact grab the &#123;&#125;&#x27;s wallet.&quot;, target); &#125;&#125;public class HitAndRunMethod extends StealingMethod &#123; private static final Logger LOGGER = LoggerFactory.getLogger(HitAndRunMethod.class); @Override protected String pickTarget() &#123; return &quot;old goblin woman&quot;; &#125; @Override protected void confuseTarget(String target) &#123; LOGGER.info(&quot;Approach the &#123;&#125; from behind.&quot;, target); &#125; @Override protected void stealTheItem(String target) &#123; LOGGER.info(&quot;Grab the handbag and run away fast!&quot;); &#125;&#125; 这是包含模板方法的半身贼类。 12345678910111213141516public class HalflingThief &#123; private StealingMethod method; public HalflingThief(StealingMethod method) &#123; this.method = method; &#125; public void steal() &#123; method.steal(); &#125; public void changeMethod(StealingMethod method) &#123; this.method = method; &#125;&#125; 最后，我们展示半身人贼如何利用不同的偷窃方法。 1234var thief = new HalflingThief(new HitAndRunMethod());thief.steal();thief.changeMethod(new SubtleMethod());thief.steal(); 类图 适用性使用模板方法模式可以 一次性实现一个算法中不变的部分并将其留给子类来实现可能变化的行为。 子类之间的共同行为应分解并集中在一个共同类中，以避免代码重复。如Opdyke和Johnson所描述的，这是“重构概括”的一个很好的例子。你首先要确定现有代码中的差异，然后将差异拆分为新的操作。最后，将不同的代码替换为调用这些新操作之一的模板方法。 控制子类扩展。您可以定义一个模板方法，该方法在特定点调用“ 钩子”操作，从而仅允许在这些点进行扩展 教程 Template-method Pattern Tutorial Java例子 javax.servlet.GenericServlet.init: Method GenericServlet.init(ServletConfig config) calls the parameterless method GenericServlet.init() which is intended to be overridden in subclasses. Method GenericServlet.init(ServletConfig config) is the template method in this example.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Strategy(策略模式)","slug":"Strategy","date":"2021-05-29T10:12:25.000Z","updated":"2021-05-29T10:21:49.342Z","comments":true,"path":"2021/05/29/Strategy/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Strategy/","excerpt":"又被称为政策（方针）模式 目的定义一个家族算法，并封装好其中每一个，使它们可以互相替换。策略模式使算法的变化独立于使用它的客户。 解释现实世界例子 屠龙是一项危险的职业。有经验将会使它变得简单。经验丰富的屠龙者对不同类型的龙有不同的战斗策略。 直白点说 策略模式允许在运行时选择最匹配的算法。 维基百科上说 在程序编程领域，策略模式（又叫政策模式）是一种启用在运行时选择算法的行为型软件设计模式。","text":"又被称为政策（方针）模式 目的定义一个家族算法，并封装好其中每一个，使它们可以互相替换。策略模式使算法的变化独立于使用它的客户。 解释现实世界例子 屠龙是一项危险的职业。有经验将会使它变得简单。经验丰富的屠龙者对不同类型的龙有不同的战斗策略。 直白点说 策略模式允许在运行时选择最匹配的算法。 维基百科上说 在程序编程领域，策略模式（又叫政策模式）是一种启用在运行时选择算法的行为型软件设计模式。 编程实例 让我们先介绍屠龙的策略模式接口和它的实现。 1234567891011121314151617181920212223242526272829303132@FunctionalInterfacepublic interface DragonSlayingStrategy &#123; void execute();&#125;@Slf4jpublic class MeleeStrategy implements DragonSlayingStrategy &#123; @Override public void execute() &#123; LOGGER.info(&quot;With your Excalibur you sever the dragon&#x27;s head!&quot;); &#125;&#125;@Slf4jpublic class ProjectileStrategy implements DragonSlayingStrategy &#123; @Override public void execute() &#123; LOGGER.info(&quot;You shoot the dragon with the magical crossbow and it falls dead on the ground!&quot;); &#125;&#125;@Slf4jpublic class SpellStrategy implements DragonSlayingStrategy &#123; @Override public void execute() &#123; LOGGER.info(&quot;You cast the spell of disintegration and the dragon vaporizes in a pile of dust!&quot;); &#125;&#125; 现在有一个强力的屠龙者要基于上面的组件来选择他的战斗策略。 12345678910111213141516public class DragonSlayer &#123; private DragonSlayingStrategy strategy; public DragonSlayer(DragonSlayingStrategy strategy) &#123; this.strategy = strategy; &#125; public void changeStrategy(DragonSlayingStrategy strategy) &#123; this.strategy = strategy; &#125; public void goToBattle() &#123; strategy.execute(); &#125;&#125; 最后是屠龙者的行动。 12345678910111213141516LOGGER.info(&quot;Green dragon spotted ahead!&quot;);var dragonSlayer = new DragonSlayer(new MeleeStrategy());dragonSlayer.goToBattle();LOGGER.info(&quot;Red dragon emerges.&quot;);dragonSlayer.changeStrategy(new ProjectileStrategy());dragonSlayer.goToBattle();LOGGER.info(&quot;Black dragon lands before you.&quot;);dragonSlayer.changeStrategy(new SpellStrategy());dragonSlayer.goToBattle();// Green dragon spotted ahead!// With your Excalibur you sever the dragon&#x27;s head!// Red dragon emerges.// You shoot the dragon with the magical crossbow and it falls dead on the ground!// Black dragon lands before you.// You cast the spell of disintegration and the dragon vaporizes in a pile of dust! 类图 应用使用策略模式当 许多相关的类只是行为不同。策略模式提供了一种为一种类配置多种行为的能力。 你需要一种算法的不同变体。比如，你可能定义反应不用时间空间权衡的算法。当这些算法的变体使用类的层次结构来实现时就可以使用策略模式。 一个算法使用的数据客户不应该对其知晓。使用策略模式来避免暴露复杂的，特定于算法的数据结构。 一个类定义了许多行为，这些行为在其操作中展现为多个条件语句。移动相关的条件分支到它们分别的策略类中来代替这些条件语句。 教学 Strategy Pattern Tutorial","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"State(状态模式)","slug":"State","date":"2021-05-29T10:09:55.000Z","updated":"2021-05-29T10:21:49.485Z","comments":true,"path":"2021/05/29/State/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/State/","excerpt":"又被称为对象状态 目的允许对象在内部状态改变时改变它的行为。对象看起来好像修改了它的类。 解释真实世界例子 当在长毛象的自然栖息地观察长毛象时，似乎它会根据情况来改变自己的行为。它开始可能很平静但是随着时间推移当它检测到威胁时它会对周围的环境感到愤怒和危险。 通俗的说 状态模式允许对象改变它的行为。 维基百科说 状态模式是一种允许对象在内部状态改变时改变它的行为的行为型设计模式。这种模式接近于有限状态机的概念。状态模式可以被理解为策略模式，它能够通过调用在模式接口中定义的方法来切换策略。","text":"又被称为对象状态 目的允许对象在内部状态改变时改变它的行为。对象看起来好像修改了它的类。 解释真实世界例子 当在长毛象的自然栖息地观察长毛象时，似乎它会根据情况来改变自己的行为。它开始可能很平静但是随着时间推移当它检测到威胁时它会对周围的环境感到愤怒和危险。 通俗的说 状态模式允许对象改变它的行为。 维基百科说 状态模式是一种允许对象在内部状态改变时改变它的行为的行为型设计模式。这种模式接近于有限状态机的概念。状态模式可以被理解为策略模式，它能够通过调用在模式接口中定义的方法来切换策略。 编程示例 这里是模式接口和它具体的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface State &#123; void onEnterState(); void observe();&#125;public class PeacefulState implements State &#123; private static final Logger LOGGER = LoggerFactory.getLogger(PeacefulState.class); private final Mammoth mammoth; public PeacefulState(Mammoth mammoth) &#123; this.mammoth = mammoth; &#125; @Override public void observe() &#123; LOGGER.info(&quot;&#123;&#125; is calm and peaceful.&quot;, mammoth); &#125; @Override public void onEnterState() &#123; LOGGER.info(&quot;&#123;&#125; calms down.&quot;, mammoth); &#125;&#125;public class AngryState implements State &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AngryState.class); private final Mammoth mammoth; public AngryState(Mammoth mammoth) &#123; this.mammoth = mammoth; &#125; @Override public void observe() &#123; LOGGER.info(&quot;&#123;&#125; is furious!&quot;, mammoth); &#125; @Override public void onEnterState() &#123; LOGGER.info(&quot;&#123;&#125; gets angry!&quot;, mammoth); &#125;&#125; 然后这里是包含状态的长毛象。 123456789101112131415161718192021222324252627282930public class Mammoth &#123; private State state; public Mammoth() &#123; state = new PeacefulState(this); &#125; public void timePasses() &#123; if (state.getClass().equals(PeacefulState.class)) &#123; changeStateTo(new AngryState(this)); &#125; else &#123; changeStateTo(new PeacefulState(this)); &#125; &#125; private void changeStateTo(State newState) &#123; this.state = newState; this.state.onEnterState(); &#125; @Override public String toString() &#123; return &quot;The mammoth&quot;; &#125; public void observe() &#123; this.state.observe(); &#125;&#125; 然后这里是长毛象随着时间的推移后的整个行为示例。 1234567891011var mammoth = new Mammoth();mammoth.observe();mammoth.timePasses();mammoth.observe();mammoth.timePasses();mammoth.observe();// The mammoth gets angry!// The mammoth is furious!// The mammoth calms down.// The mammoth is calm and peaceful. 类图 适用性在以下两种情况下，请使用State模式 对象的行为取决于它的状态，并且它必须在运行时根据状态更改其行为。 根据对象状态的不同，操作有大量的条件语句。此状态通常由一个或多个枚举常量表示。通常，几个操作将包含此相同的条件结构。状态模式把条件语句的分支分别放入单独的类中。这样一来，你就可以将对象的状态视为独立的对象，该对象可以独立于其他对象而变化。 Java中例子 javax.faces.lifecycle.Lifecycle#execute() controlled by FacesServlet, the behavior is dependent on current phase of lifecycle. JDiameter - Diameter State Machine","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Observer(观察者模式)","slug":"Observer","date":"2021-05-29T10:06:54.000Z","updated":"2021-05-29T10:21:49.309Z","comments":true,"path":"2021/05/29/Observer/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Observer/","excerpt":"又被称为家属，发布订阅模式 目的定义一种一对多的对象依赖关系这样当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。 解释真实世界例子 在遥远的土地上生活着霍比特人和兽人的种族。他们都是户外生活的人所以他们密切关注天气的变化。可以说他们不断地关注着天气。 通俗的说 注册成为一个观察者以接收对象状态的改变。 维基百科说 观察者模式是这样的一种软件设计模式：它有一个被称为主题的对象，维护着一个所有依赖于它的依赖者清单，也就是观察者清单，当主题的状态发生改变时，主题通常会调用观察者的方法来自动通知观察者们。","text":"又被称为家属，发布订阅模式 目的定义一种一对多的对象依赖关系这样当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。 解释真实世界例子 在遥远的土地上生活着霍比特人和兽人的种族。他们都是户外生活的人所以他们密切关注天气的变化。可以说他们不断地关注着天气。 通俗的说 注册成为一个观察者以接收对象状态的改变。 维基百科说 观察者模式是这样的一种软件设计模式：它有一个被称为主题的对象，维护着一个所有依赖于它的依赖者清单，也就是观察者清单，当主题的状态发生改变时，主题通常会调用观察者的方法来自动通知观察者们。 编程示例 让我们先来介绍天气观察者的接口以及我们的种族，兽人和霍比特人。 1234567891011121314151617181920212223public interface WeatherObserver &#123; void update(WeatherType currentWeather);&#125;@Slf4jpublic class Orcs implements WeatherObserver &#123; @Override public void update(WeatherType currentWeather) &#123; LOGGER.info(&quot;The orcs are facing &quot; + currentWeather.getDescription() + &quot; weather now&quot;); &#125;&#125;@Slf4jpublic class Hobbits implements WeatherObserver &#123; @Override public void update(WeatherType currentWeather) &#123; switch (currentWeather) &#123; LOGGER.info(&quot;The hobbits are facing &quot; + currentWeather.getDescription() + &quot; weather now&quot;); &#125;&#125; 然后这里是不断变化的天气。 1234567891011121314151617181920212223242526272829303132333435@Slf4jpublic class Weather &#123; private WeatherType currentWeather; private final List&lt;WeatherObserver&gt; observers; public Weather() &#123; observers = new ArrayList&lt;&gt;(); currentWeather = WeatherType.SUNNY; &#125; public void addObserver(WeatherObserver obs) &#123; observers.add(obs); &#125; public void removeObserver(WeatherObserver obs) &#123; observers.remove(obs); &#125; /** * Makes time pass for weather. */ public void timePasses() &#123; var enumValues = WeatherType.values(); currentWeather = enumValues[(currentWeather.ordinal() + 1) % enumValues.length]; LOGGER.info(&quot;The weather changed to &#123;&#125;.&quot;, currentWeather); notifyObservers(); &#125; private void notifyObservers() &#123; for (var obs : observers) &#123; obs.update(currentWeather); &#125; &#125;&#125; 这是完整的示例。 1234567891011121314151617181920var weather = new Weather();weather.addObserver(new Orcs());weather.addObserver(new Hobbits());weather.timePasses();// The weather changed to rainy.// The orcs are facing rainy weather now// The hobbits are facing rainy weather nowweather.timePasses();// The weather changed to windy.// The orcs are facing windy weather now// The hobbits are facing windy weather nowweather.timePasses();// The weather changed to cold.// The orcs are facing cold weather now// The hobbits are facing cold weather nowweather.timePasses();// The weather changed to sunny.// The orcs are facing sunny weather now// The hobbits are facing sunny weather now Class diagram 应用在下面任何一种情况下都可以使用观察者模式 当抽象具有两个方面时，一个方面依赖于另一个方面。将这些方面封装在单独的对象中，可以使你分别进行更改和重用 当一个对象的改变的同时需要改变其他对象，同时你又不知道有多少对象需要改变时 当一个对象可以通知其他对象而无需假设这些对象是谁时。换句话说，你不想让这些对象紧耦合。 典型用例 一个对象的改变导致其他对象的改变 Java中的例子 java.util.Observer java.util.EventListener javax.servlet.http.HttpSessionBindingListener RxJava","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Memento(备忘录模式)","slug":"Memento","date":"2021-05-29T10:00:01.000Z","updated":"2021-05-29T10:21:48.898Z","comments":true,"path":"2021/05/29/Memento/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Memento/","excerpt":"又名/别称Token|快照模式(Snapshot Pattern) 目的在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后可以将对象恢复到该状态。 解释真实世界例子 我们正在研究占星术应用程序，我们需要随着时间的推移分析恒星属性。 我们正在使用 备忘录模式创建星状态的快照。 通俗的说 备忘录模式捕获对象内部状态，可以轻松地在任何时间点存储和恢复对象。 维基百科上说 备忘录模式是一种软件设计模式，它提供了将对象恢复到其先前状态（通过回滚撤消）的能力。","text":"又名/别称Token|快照模式(Snapshot Pattern) 目的在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后可以将对象恢复到该状态。 解释真实世界例子 我们正在研究占星术应用程序，我们需要随着时间的推移分析恒星属性。 我们正在使用 备忘录模式创建星状态的快照。 通俗的说 备忘录模式捕获对象内部状态，可以轻松地在任何时间点存储和恢复对象。 维基百科上说 备忘录模式是一种软件设计模式，它提供了将对象恢复到其先前状态（通过回滚撤消）的能力。 程序示例 让我们首先定义我们能够处理的恒星类型。 12345678public enum StarType &#123; SUN(&quot;sun&quot;), RED_GIANT(&quot;red giant&quot;), WHITE_DWARF(&quot;white dwarf&quot;), SUPERNOVA(&quot;supernova&quot;), DEAD(&quot;dead star&quot;); ...&#125; 接下来，让我们直接跳到要点。 这是 Star 类以及我们需要操作的备忘录。 特别注意 getMemento 和 setMemento 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface StarMemento &#123;&#125;public class Star &#123; private StarType type; private int ageYears; private int massTons; public Star(StarType startType, int startAge, int startMass) &#123; this.type = startType; this.ageYears = startAge; this.massTons = startMass; &#125; public void timePasses() &#123; ageYears *= 2; massTons *= 8; switch (type) &#123; case RED_GIANT: type = StarType.WHITE_DWARF; break; case SUN: type = StarType.RED_GIANT; break; case SUPERNOVA: type = StarType.DEAD; break; case WHITE_DWARF: type = StarType.SUPERNOVA; break; case DEAD: ageYears *= 2; massTons = 0; break; default: break; &#125; &#125; StarMemento getMemento() &#123; var state = new StarMementoInternal(); state.setAgeYears(ageYears); state.setMassTons(massTons); state.setType(type); return state; &#125; void setMemento(StarMemento memento) &#123; var state = (StarMementoInternal) memento; this.type = state.getType(); this.ageYears = state.getAgeYears(); this.massTons = state.getMassTons(); &#125; @Override public String toString() &#123; return String.format(&quot;%s age: %d years mass: %d tons&quot;, type.toString(), ageYears, massTons); &#125; private static class StarMementoInternal implements StarMemento &#123; private StarType type; private int ageYears; private int massTons; // setters and getters -&gt; ... &#125;&#125; 最后是我们如何使用备忘录来存储和恢复恒星状态。 12345678910111213141516171819var states = new Stack&lt;&gt;();var star = new Star(StarType.SUN, 10000000, 500000);LOGGER.info(star.toString());states.add(star.getMemento());star.timePasses();LOGGER.info(star.toString());states.add(star.getMemento());star.timePasses();LOGGER.info(star.toString());states.add(star.getMemento());star.timePasses();LOGGER.info(star.toString());states.add(star.getMemento());star.timePasses();LOGGER.info(star.toString());while (states.size() &gt; 0) &#123; star.setMemento(states.pop()); LOGGER.info(star.toString());&#125; 程序示例输出: 123456789sun age: 10000000 years mass: 500000 tonsred giant age: 20000000 years mass: 4000000 tonswhite dwarf age: 40000000 years mass: 32000000 tonssupernova age: 80000000 years mass: 256000000 tonsdead star age: 160000000 years mass: 2048000000 tonssupernova age: 80000000 years mass: 256000000 tonswhite dwarf age: 40000000 years mass: 32000000 tonsred giant age: 20000000 years mass: 4000000 tonssun age: 10000000 years mass: 500000 tons 类图 适用性使用备忘录模式时 必须保存对象状态的快照，以便稍后可以将其恢复到该状态，并且 获取状态的直接接口会暴露实现细节并破坏对象的封装 Java世界例子 java.util.Date","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mediator(中介者模式)","slug":"Mediator","date":"2021-05-29T09:57:50.000Z","updated":"2021-05-29T10:21:49.449Z","comments":true,"path":"2021/05/29/Mediator/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Mediator/","excerpt":"Intent定义一个封装一组对象如何交互的对象。 调解器通过防止对象明确地相互引用来促进松散耦合，并且它允许您独立地改变它们的交互。","text":"Intent定义一个封装一组对象如何交互的对象。 调解器通过防止对象明确地相互引用来促进松散耦合，并且它允许您独立地改变它们的交互。 类图 适用性在以下情况下使用中介者模式 一组对象以定义明确但复杂的方式进行通信。 由此产生的相互依赖是非结构化的，难以理解 重用一个对象很困难，因为它引用了许多其他对象并与之通信 分布在多个类之间的行为应该是可定制的，无需大量子类化 Java世界例子 All scheduleXXX() methods of java.util.Timer java.util.concurrent.Executor#execute() submit() and invokeXXX() methods of java.util.concurrent.ExecutorService scheduleXXX() methods of java.util.concurrent.ScheduledExecutorService java.lang.reflect.Method#invoke()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Iterator(迭代器模式)","slug":"Iterator","date":"2021-05-29T09:56:18.000Z","updated":"2021-05-29T10:21:48.743Z","comments":true,"path":"2021/05/29/Iterator/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Iterator/","excerpt":"又被称为游标 目的提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。 解释真实世界例子 百宝箱包含一组魔法物品。有多种物品，例如戒指，药水和武器。可以使用藏宝箱提供的迭代器按类型浏览商品。 通俗地说 容器可以提供与表示形式无关的迭代器接口，以提供对元素的访问。 维基百科说 在面向对象的编程中，迭代器模式是一种设计模式，其中迭代器用于遍历容器并访问容器的元素。","text":"又被称为游标 目的提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。 解释真实世界例子 百宝箱包含一组魔法物品。有多种物品，例如戒指，药水和武器。可以使用藏宝箱提供的迭代器按类型浏览商品。 通俗地说 容器可以提供与表示形式无关的迭代器接口，以提供对元素的访问。 维基百科说 在面向对象的编程中，迭代器模式是一种设计模式，其中迭代器用于遍历容器并访问容器的元素。 程序示例 在我们的示例中包含物品的藏宝箱是主要类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TreasureChest &#123; private final List&lt;Item&gt; items; public TreasureChest() &#123; items = List.of( new Item(ItemType.POTION, &quot;Potion of courage&quot;), new Item(ItemType.RING, &quot;Ring of shadows&quot;), new Item(ItemType.POTION, &quot;Potion of wisdom&quot;), new Item(ItemType.POTION, &quot;Potion of blood&quot;), new Item(ItemType.WEAPON, &quot;Sword of silver +1&quot;), new Item(ItemType.POTION, &quot;Potion of rust&quot;), new Item(ItemType.POTION, &quot;Potion of healing&quot;), new Item(ItemType.RING, &quot;Ring of armor&quot;), new Item(ItemType.WEAPON, &quot;Steel halberd&quot;), new Item(ItemType.WEAPON, &quot;Dagger of poison&quot;)); &#125; public Iterator&lt;Item&gt; iterator(ItemType itemType) &#123; return new TreasureChestItemIterator(this, itemType); &#125; public List&lt;Item&gt; getItems() &#123; return new ArrayList&lt;&gt;(items); &#125;&#125;public class Item &#123; private ItemType type; private final String name; public Item(ItemType type, String name) &#123; this.setType(type); this.name = name; &#125; @Override public String toString() &#123; return name; &#125; public ItemType getType() &#123; return type; &#125; public final void setType(ItemType type) &#123; this.type = type; &#125;&#125;public enum ItemType &#123; ANY, WEAPON, RING, POTION&#125; 迭代器接口极度简单。 123456public interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next();&#125; 在以下示例中，我们遍历在宝箱中找到的戒指类型物品。 123456var itemIterator = TREASURE_CHEST.iterator(ItemType.RING);while (itemIterator.hasNext()) &#123; LOGGER.info(itemIterator.next().toString());&#125;// Ring of shadows// Ring of armor 类图 适用性以下情况使用迭代器模式 在不暴露其内部表示的情况下访问聚合对象的内容 为了支持聚合对象的多种遍历方式 提供一个遍历不同聚合结构的统一接口 Java世界例子 java.util.Iterator java.util.Enumeration","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Interpreter(解释器模式)","slug":"Interpreter","date":"2021-05-29T09:54:08.000Z","updated":"2021-05-29T10:21:49.236Z","comments":true,"path":"2021/05/29/Interpreter/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Interpreter/","excerpt":"目的给定一种语言，请定义其语法的表示形式，以及使用该表示形式来解释该语言中的句子的解释器。","text":"目的给定一种语言，请定义其语法的表示形式，以及使用该表示形式来解释该语言中的句子的解释器。 类图 适用性有一种要解释的语言时，请使用解释器模式，并且可以将语言中的语句表示为抽象语法树。解释器模式在以下情况下效果最佳 语法很简单。 对于复杂的语法，语法的类层次结构变得庞大且难以管理。 在这种情况下，解析器生成器之类的工具是更好的选择。 他们可以在不构建抽象语法树的情况下解释表达式，这可以节省空间并可能节省时间 效率不是关键问题。 通常，最有效的解释器不是通过直接解释解析树来实现的，而是先将其转换为另一种形式。 例如，正则表达式通常会转换为状态机。 但是即使这样，翻译器也可以通过解释器模式实现，因此该模式仍然适用。 真实世界例子 java.util.Pattern java.text.Normalizer All subclasses of java.text.Format javax.el.ELResolver","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Command (命令模式)","slug":"Command","date":"2021-05-29T09:52:10.000Z","updated":"2021-05-29T10:21:49.524Z","comments":true,"path":"2021/05/29/Command/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Command/","excerpt":"或称行动, 事务模式 目的将请求封装为对象，从而使你可以将具有不同请求的客户端参数化，队列或记录请求，并且支持可撤销操作。 解释真实世界例子 有一个巫师在地精上施放咒语。咒语在地精上一一执行。第一个咒语使地精缩小，第二个使他不可见。然后巫师将咒语一个个的反转。这里的每一个咒语都是一个可撤销的命令对象。 用通俗的话说 用命令对象的方式存储请求以在将来时可以执行它或撤销它。 维基百科说 在面向对象编程中，命令模式是一种行为型设计模式，它把在稍后执行的一个动作或触发的一个事件所需要的所有信息封装到一个对象中。","text":"或称行动, 事务模式 目的将请求封装为对象，从而使你可以将具有不同请求的客户端参数化，队列或记录请求，并且支持可撤销操作。 解释真实世界例子 有一个巫师在地精上施放咒语。咒语在地精上一一执行。第一个咒语使地精缩小，第二个使他不可见。然后巫师将咒语一个个的反转。这里的每一个咒语都是一个可撤销的命令对象。 用通俗的话说 用命令对象的方式存储请求以在将来时可以执行它或撤销它。 维基百科说 在面向对象编程中，命令模式是一种行为型设计模式，它把在稍后执行的一个动作或触发的一个事件所需要的所有信息封装到一个对象中。 编程示例 这是巫师和地精的示例代码。让我们从巫师类开始。 1234567891011121314151617181920212223242526272829303132333435363738public class Wizard &#123; private static final Logger LOGGER = LoggerFactory.getLogger(Wizard.class); private final Deque&lt;Command&gt; undoStack = new LinkedList&lt;&gt;(); private final Deque&lt;Command&gt; redoStack = new LinkedList&lt;&gt;(); public Wizard() &#123;&#125; public void castSpell(Command command, Target target) &#123; LOGGER.info(&quot;&#123;&#125; casts &#123;&#125; at &#123;&#125;&quot;, this, command, target); command.execute(target); undoStack.offerLast(command); &#125; public void undoLastSpell() &#123; if (!undoStack.isEmpty()) &#123; var previousSpell = undoStack.pollLast(); redoStack.offerLast(previousSpell); LOGGER.info(&quot;&#123;&#125; undoes &#123;&#125;&quot;, this, previousSpell); previousSpell.undo(); &#125; &#125; public void redoLastSpell() &#123; if (!redoStack.isEmpty()) &#123; var previousSpell = redoStack.pollLast(); undoStack.offerLast(previousSpell); LOGGER.info(&quot;&#123;&#125; redoes &#123;&#125;&quot;, this, previousSpell); previousSpell.redo(); &#125; &#125; @Override public String toString() &#123; return &quot;Wizard&quot;; &#125;&#125; 接下来我们介绍咒语层级 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public interface Command &#123; void execute(Target target); void undo(); void redo(); String toString();&#125;public class InvisibilitySpell implements Command &#123; private Target target; @Override public void execute(Target target) &#123; target.setVisibility(Visibility.INVISIBLE); this.target = target; &#125; @Override public void undo() &#123; if (target != null) &#123; target.setVisibility(Visibility.VISIBLE); &#125; &#125; @Override public void redo() &#123; if (target != null) &#123; target.setVisibility(Visibility.INVISIBLE); &#125; &#125; @Override public String toString() &#123; return &quot;Invisibility spell&quot;; &#125;&#125;public class ShrinkSpell implements Command &#123; private Size oldSize; private Target target; @Override public void execute(Target target) &#123; oldSize = target.getSize(); target.setSize(Size.SMALL); this.target = target; &#125; @Override public void undo() &#123; if (oldSize != null &amp;&amp; target != null) &#123; var temp = target.getSize(); target.setSize(oldSize); oldSize = temp; &#125; &#125; @Override public void redo() &#123; undo(); &#125; @Override public String toString() &#123; return &quot;Shrink spell&quot;; &#125;&#125; 最后我们有咒语的目标地精。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Target &#123; private static final Logger LOGGER = LoggerFactory.getLogger(Target.class); private Size size; private Visibility visibility; public Size getSize() &#123; return size; &#125; public void setSize(Size size) &#123; this.size = size; &#125; public Visibility getVisibility() &#123; return visibility; &#125; public void setVisibility(Visibility visibility) &#123; this.visibility = visibility; &#125; @Override public abstract String toString(); public void printStatus() &#123; LOGGER.info(&quot;&#123;&#125;, [size=&#123;&#125;] [visibility=&#123;&#125;]&quot;, this, getSize(), getVisibility()); &#125;&#125;public class Goblin extends Target &#123; public Goblin() &#123; setSize(Size.NORMAL); setVisibility(Visibility.VISIBLE); &#125; @Override public String toString() &#123; return &quot;Goblin&quot;; &#125;&#125; 最后是整个示例的实践。 12345678910111213141516var wizard = new Wizard();var goblin = new Goblin();goblin.printStatus();// Goblin, [size=normal] [visibility=visible]wizard.castSpell(new ShrinkSpell(), goblin);// Wizard casts Shrink spell at Goblingoblin.printStatus();// Goblin, [size=small] [visibility=visible]wizard.castSpell(new InvisibilitySpell(), goblin);// Wizard casts Invisibility spell at Goblingoblin.printStatus();// Goblin, [size=small] [visibility=invisible]wizard.undoLastSpell();// Wizard undoes Invisibility spellgoblin.printStatus();// Goblin, [size=small] [visibility=visible] 类图 适用性使用命令模式当你想 通过操作将对象参数化。您可以使用回调函数（即，已在某处注册以便稍后调用的函数）以过程语言表示这种参数化。命令是回调的一种面向对象替代方案。 在不同的时间指定，排队和执行请求。一个命令对象的生存期可以独立于原始请求。如果请求的接收方可以以地址空间无关的方式来表示，那么你可以将请求的命令对象传输到其他进程并在那里执行请求。 支持撤销。命令的执行操作可以在命令本身中存储状态以反转其效果。命令接口必须有添加的反执行操作，该操作可以逆转上一次执行调用的效果。执行的命令存储在历史列表中。无限撤消和重做通过分别向后和向前遍历此列表来实现，分别调用unexecute和execute。 支持日志记录更改，以便在系统崩溃时可以重新应用它们。通过使用加载和存储操作扩展命令接口，你可以保留更改的永久日志。从崩溃中恢复涉及从磁盘重新加载记录的命令，并通过执行操作重新执行它们。 通过原始的操作来构建一个以高级操作围绕的系统。这种结构在支持事务的信息系统中很常见。事务封装了一组数据更改。命令模式提供了一种对事务进行建模的方法。命令具有公共接口，让你以相同的方式调用所有事务。该模式还可以通过新的事务来轻松扩展系统。 典型用例 保留请求历史 实现回调功能 实现撤销功能 Java世界例子 java.lang.Runnable org.junit.runners.model.Statement Netflix Hystrix javax.swing.Action","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Chain of responsibility(责任链模式)","slug":"Chain","date":"2021-05-29T09:50:42.000Z","updated":"2021-05-29T10:21:49.156Z","comments":true,"path":"2021/05/29/Chain/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Chain/","excerpt":"目的通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。 解释真实世界例子 兽王大声命令他的军队。最近响应的是指挥官，然后是军官，然后是士兵。指挥官，军官，士兵这里就形成了一个责任链。 通俗的说 它帮助构建一串对象。请求从一个对象中进入并结束然后进入到一个个对象中直到找到合适的处理器。 维基百科说 在面向对象设计中，责任链模式是一种由源命令对象和一系列处理对象组成的设计模式。每个处理对象包含了其定义的可处理的命令对象类型的逻辑。剩下的会传递给链条中的下一个处理对象。","text":"目的通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。 解释真实世界例子 兽王大声命令他的军队。最近响应的是指挥官，然后是军官，然后是士兵。指挥官，军官，士兵这里就形成了一个责任链。 通俗的说 它帮助构建一串对象。请求从一个对象中进入并结束然后进入到一个个对象中直到找到合适的处理器。 维基百科说 在面向对象设计中，责任链模式是一种由源命令对象和一系列处理对象组成的设计模式。每个处理对象包含了其定义的可处理的命令对象类型的逻辑。剩下的会传递给链条中的下一个处理对象。 程序示例 用上面的兽人来翻译我们的示例。首先我们有请求类 1234567891011121314151617181920212223242526public class Request &#123; private final RequestType requestType; private final String requestDescription; private boolean handled; public Request(final RequestType requestType, final String requestDescription) &#123; this.requestType = Objects.requireNonNull(requestType); this.requestDescription = Objects.requireNonNull(requestDescription); &#125; public String getRequestDescription() &#123; return requestDescription; &#125; public RequestType getRequestType() &#123; return requestType; &#125; public void markHandled() &#123; this.handled = true; &#125; public boolean isHandled() &#123; return this.handled; &#125; @Override public String toString() &#123; return getRequestDescription(); &#125;&#125;public enum RequestType &#123; DEFEND_CASTLE, TORTURE_PRISONER, COLLECT_TAX&#125; 然后是请求处理器的层次结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Slf4jpublic abstract class RequestHandler &#123; private final RequestHandler next; public RequestHandler(RequestHandler next) &#123; this.next = next; &#125; public void handleRequest(Request req) &#123; if (next != null) &#123; next.handleRequest(req); &#125; &#125; protected void printHandling(Request req) &#123; LOGGER.info(&quot;&#123;&#125; handling request \\&quot;&#123;&#125;\\&quot;&quot;, this, req); &#125; @Override public abstract String toString();&#125;public class OrcCommander extends RequestHandler &#123; public OrcCommander(RequestHandler handler) &#123; super(handler); &#125; @Override public void handleRequest(Request req) &#123; if (req.getRequestType().equals(RequestType.DEFEND_CASTLE)) &#123; printHandling(req); req.markHandled(); &#125; else &#123; super.handleRequest(req); &#125; &#125; @Override public String toString() &#123; return &quot;Orc commander&quot;; &#125;&#125;// OrcOfficer和OrcSoldier的定义与OrcCommander类似 然后我们有兽王下达命令并形成链条 123456789101112131415public class OrcKing &#123; RequestHandler chain; public OrcKing() &#123; buildChain(); &#125; private void buildChain() &#123; chain = new OrcCommander(new OrcOfficer(new OrcSoldier(null))); &#125; public void makeRequest(Request req) &#123; chain.handleRequest(req); &#125;&#125; 然后这样使用它 1234var king = new OrcKing();king.makeRequest(new Request(RequestType.DEFEND_CASTLE, &quot;defend castle&quot;)); // Orc commander handling request &quot;defend castle&quot;king.makeRequest(new Request(RequestType.TORTURE_PRISONER, &quot;torture prisoner&quot;)); // Orc officer handling request &quot;torture prisoner&quot;king.makeRequest(new Request(RequestType.COLLECT_TAX, &quot;collect tax&quot;)); // Orc soldier handling request &quot;collect tax&quot; 类图 适用性使用责任链模式当 多于一个对象可能要处理请求，并且处理器并不知道一个优先级。处理器应自动确定。 你想对多个对象之一发出请求而无需明确指定接收者 处理请求的对象集合应该被动态指定时 Java世界例子 [java.util.logging.Logger#log()](http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log(java.util.logging.Level, java.lang.String)) Apache Commons Chain javax.servlet.Filter#doFilter()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Proxy(代理模式)","slug":"Proxy","date":"2021-05-29T09:33:34.000Z","updated":"2021-05-29T10:49:04.302Z","comments":true,"path":"2021/05/29/Proxy/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Proxy/","excerpt":"又被称为替代（代孕）模式 目的为另一个对象提供代理或占位符以控制对其的访问。 解释真实世界例子 想象有一个塔，当地的巫师去那里学习他们的法术。象牙塔只能够通过代理来进入以此来保证只有首先3个巫师才能进入。这里的代理就代表的塔的功能并添加访问控制。 通俗的说 使用代理模式，一个类代表另一个类的功能。 维基百科说 在最一般的形式上，代理是一个类，它充当与其他对象的接口。代理是客户端调用的包装器或代理对象，以访问后台的实际服务对象。代理本身可以简单地转发到真实对象，也可以提供其他逻辑。在代理中，可以提供额外的功能，例如在对实对象的操作占用大量资源时进行缓存，或者在对实对象的操作被调用之前检查前提条件。","text":"又被称为替代（代孕）模式 目的为另一个对象提供代理或占位符以控制对其的访问。 解释真实世界例子 想象有一个塔，当地的巫师去那里学习他们的法术。象牙塔只能够通过代理来进入以此来保证只有首先3个巫师才能进入。这里的代理就代表的塔的功能并添加访问控制。 通俗的说 使用代理模式，一个类代表另一个类的功能。 维基百科说 在最一般的形式上，代理是一个类，它充当与其他对象的接口。代理是客户端调用的包装器或代理对象，以访问后台的实际服务对象。代理本身可以简单地转发到真实对象，也可以提供其他逻辑。在代理中，可以提供额外的功能，例如在对实对象的操作占用大量资源时进行缓存，或者在对实对象的操作被调用之前检查前提条件。 程序示例 使用上面的巫师塔为例。首先我们有巫师塔接口和象牙塔类 。 1234567891011121314public interface WizardTower &#123; void enter(Wizard wizard);&#125;public class IvoryTower implements WizardTower &#123; private static final Logger LOGGER = LoggerFactory.getLogger(IvoryTower.class); public void enter(Wizard wizard) &#123; LOGGER.info(&quot;&#123;&#125; enters the tower.&quot;, wizard); &#125;&#125; 然后有个简单的巫师类。 12345678910111213public class Wizard &#123; private final String name; public Wizard(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return name; &#125;&#125; 然后我们有巫师塔代理类为巫师塔添加访问控制。 123456789101112131415161718192021222324public class WizardTowerProxy implements WizardTower &#123; private static final Logger LOGGER = LoggerFactory.getLogger(WizardTowerProxy.class); private static final int NUM_WIZARDS_ALLOWED = 3; private int numWizards; private final WizardTower tower; public WizardTowerProxy(WizardTower tower) &#123; this.tower = tower; &#125; @Override public void enter(Wizard wizard) &#123; if (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123; tower.enter(wizard); numWizards++; &#125; else &#123; LOGGER.info(&quot;&#123;&#125; is not allowed to enter!&quot;, wizard); &#125; &#125;&#125; 然后这是进入塔的场景。 123456var proxy = new WizardTowerProxy(new IvoryTower());proxy.enter(new Wizard(&quot;Red wizard&quot;));proxy.enter(new Wizard(&quot;White wizard&quot;));proxy.enter(new Wizard(&quot;Black wizard&quot;));proxy.enter(new Wizard(&quot;Green wizard&quot;));proxy.enter(new Wizard(&quot;Brown wizard&quot;)); 程序输出： 12345Red wizard enters the tower.White wizard enters the tower.Black wizard enters the tower.Green wizard is not allowed to enter!Brown wizard is not allowed to enter! 类图 适用性代理适用于需要比简单指针更广泛或更复杂的对象引用的情况。这是代理模式适用的几种常见情况。 远程代理为不同地址空间中的对象提供了本地代表。 虚拟代理根据需要创建昂贵的对象。 保护代理控制对原始对象的访问。当对象有不同的接入权限时保护代理很有用。 典型用例 对象的访问控制 懒加载 实现日志记录 简化网络连接 对象的访问计数 教程 Controlling Access With Proxy Pattern Java世界使用 java.lang.reflect.Proxy Apache Commons Proxy Mocking frameworks Mockito, Powermock, EasyMock 相关设计模式 Ambassador","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Flyweight (享元模式)","slug":"Flyweight","date":"2021-05-29T09:27:19.000Z","updated":"2021-05-29T10:49:04.217Z","comments":true,"path":"2021/05/29/Flyweight/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Flyweight/","excerpt":"目的使用共享有效地支持大量细粒度对象。 解释真实世界的例子 炼金术士商店的货架上摆满了魔法药水。 许多药水是相同的，因此无需为每个药水创建新对象。 相反，一个对象实例可以表示多个货架项目，因此内存占用仍然很小。 通俗的说 它用于通过尽可能多地与相似对象共享来最小化内存使用或计算开销。 维基百科上说 在计算机编程中，享元是一种软件设计模式。 享元是通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象； 当简单的重复表示会使用不可接受的内存量时，这是一种使用大量对象的方法。","text":"目的使用共享有效地支持大量细粒度对象。 解释真实世界的例子 炼金术士商店的货架上摆满了魔法药水。 许多药水是相同的，因此无需为每个药水创建新对象。 相反，一个对象实例可以表示多个货架项目，因此内存占用仍然很小。 通俗的说 它用于通过尽可能多地与相似对象共享来最小化内存使用或计算开销。 维基百科上说 在计算机编程中，享元是一种软件设计模式。 享元是通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象； 当简单的重复表示会使用不可接受的内存量时，这是一种使用大量对象的方法。 程序示例 从上面翻译我们炼金术士商店的例子。 首先，我们有不同的药水类型： 123456789101112131415161718192021222324252627public interface Potion &#123; void drink();&#125;@Slf4jpublic class HealingPotion implements Potion &#123; @Override public void drink() &#123; LOGGER.info(&quot;You feel healed. (Potion=&#123;&#125;)&quot;, System.identityHashCode(this)); &#125;&#125;@Slf4jpublic class HolyWaterPotion implements Potion &#123; @Override public void drink() &#123; LOGGER.info(&quot;You feel blessed. (Potion=&#123;&#125;)&quot;, System.identityHashCode(this)); &#125;&#125;@Slf4jpublic class InvisibilityPotion implements Potion &#123; @Override public void drink() &#123; LOGGER.info(&quot;You become invisible. (Potion=&#123;&#125;)&quot;, System.identityHashCode(this)); &#125;&#125; 然后是实际的 Flyweight 类“PotionFactory”，它是创建药水的工厂。 12345678910111213141516171819202122232425262728293031public class PotionFactory &#123; private final Map&lt;PotionType, Potion&gt; potions; public PotionFactory() &#123; potions = new EnumMap&lt;&gt;(PotionType.class); &#125; Potion createPotion(PotionType type) &#123; var potion = potions.get(type); if (potion == null) &#123; switch (type) &#123; case HEALING: potion = new HealingPotion(); potions.put(type, potion); break; case HOLY_WATER: potion = new HolyWaterPotion(); potions.put(type, potion); break; case INVISIBILITY: potion = new InvisibilityPotion(); potions.put(type, potion); break; default: break; &#125; &#125; return potion; &#125;&#125; 它可以如下使用： 1234567var factory = new PotionFactory();factory.createPotion(PotionType.INVISIBILITY).drink(); // You become invisible. (Potion=6566818)factory.createPotion(PotionType.HEALING).drink(); // You feel healed. (Potion=648129364)factory.createPotion(PotionType.INVISIBILITY).drink(); // You become invisible. (Potion=6566818)factory.createPotion(PotionType.HOLY_WATER).drink(); // You feel blessed. (Potion=1104106489)factory.createPotion(PotionType.HOLY_WATER).drink(); // You feel blessed. (Potion=1104106489)factory.createPotion(PotionType.HEALING).drink(); // You feel healed. (Potion=648129364) 程序示例输出: 123456You become invisible. (Potion=6566818)You feel healed. (Potion=648129364)You become invisible. (Potion=6566818)You feel blessed. (Potion=1104106489)You feel blessed. (Potion=1104106489)You feel healed. (Potion=648129364) 类图 适用性Flyweight 模式的有效性在很大程度上取决于它的使用方式和位置。 当以下所有条件都为真时，应用享元模式： 应用程序使用大量对象。 由于物品数量庞大，存储成本很高。 大多数对象状态可以是外在的。 一旦外部状态被移除，许多对象组可能会被相对较少的共享对象替换。 应用程序不依赖于对象标识。 由于享元对象可能是共享的，因此对于概念上不同的对象，身份测试将返回 true。 Java世界使用 int 包括其他的byte和char等包装类.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Facade(外观模式)","slug":"Facade","date":"2021-05-29T09:19:16.000Z","updated":"2021-05-29T10:21:49.062Z","comments":true,"path":"2021/05/29/Facade/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Facade/","excerpt":"目的为一个子系统中的一系列接口提供一个统一的接口。外观定义了一个更高级别的接口以便子系统更容易使用。 解释真实世界的例子 一个金矿是怎么工作的？“嗯，矿工下去然后挖金子！”你说。这是你所相信的因为你在使用一个金矿对外提供的一个简单接口，在内部它要却要做很多事情。这个简单的接口对复杂的子系统来说就是一个外观。 用通俗的话说 外观模式为一个复杂的子系统提供一个简单的接口。 维基百科说 外观是为很大体量的代码（比如类库）提供简单接口的一种对象。","text":"目的为一个子系统中的一系列接口提供一个统一的接口。外观定义了一个更高级别的接口以便子系统更容易使用。 解释真实世界的例子 一个金矿是怎么工作的？“嗯，矿工下去然后挖金子！”你说。这是你所相信的因为你在使用一个金矿对外提供的一个简单接口，在内部它要却要做很多事情。这个简单的接口对复杂的子系统来说就是一个外观。 用通俗的话说 外观模式为一个复杂的子系统提供一个简单的接口。 维基百科说 外观是为很大体量的代码（比如类库）提供简单接口的一种对象。 程序示例 使用上面金矿的例子。这里我们有矮人的矿工等级制度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Slf4jpublic abstract class DwarvenMineWorker &#123; public void goToSleep() &#123; LOGGER.info(&quot;&#123;&#125; goes to sleep.&quot;, name()); &#125; public void wakeUp() &#123; LOGGER.info(&quot;&#123;&#125; wakes up.&quot;, name()); &#125; public void goHome() &#123; LOGGER.info(&quot;&#123;&#125; goes home.&quot;, name()); &#125; public void goToMine() &#123; LOGGER.info(&quot;&#123;&#125; goes to the mine.&quot;, name()); &#125; private void action(Action action) &#123; switch (action) &#123; case GO_TO_SLEEP: goToSleep(); break; case WAKE_UP: wakeUp(); break; case GO_HOME: goHome(); break; case GO_TO_MINE: goToMine(); break; case WORK: work(); break; default: LOGGER.info(&quot;Undefined action&quot;); break; &#125; &#125; public void action(Action... actions) &#123; Arrays.stream(actions).forEach(this::action); &#125; public abstract void work(); public abstract String name(); enum Action &#123; GO_TO_SLEEP, WAKE_UP, GO_HOME, GO_TO_MINE, WORK &#125;&#125;@Slf4jpublic class DwarvenTunnelDigger extends DwarvenMineWorker &#123; @Override public void work() &#123; LOGGER.info(&quot;&#123;&#125; creates another promising tunnel.&quot;, name()); &#125; @Override public String name() &#123; return &quot;Dwarven tunnel digger&quot;; &#125;&#125;@Slf4jpublic class DwarvenGoldDigger extends DwarvenMineWorker &#123; @Override public void work() &#123; LOGGER.info(&quot;&#123;&#125; digs for gold.&quot;, name()); &#125; @Override public String name() &#123; return &quot;Dwarf gold digger&quot;; &#125;&#125;@Slf4jpublic class DwarvenCartOperator extends DwarvenMineWorker &#123; @Override public void work() &#123; LOGGER.info(&quot;&#123;&#125; moves gold chunks out of the mine.&quot;, name()); &#125; @Override public String name() &#123; return &quot;Dwarf cart operator&quot;; &#125;&#125; 为了操纵所有这些矿工我们有了这个外观 12345678910111213141516171819202122232425262728public class DwarvenGoldmineFacade &#123; private final List&lt;DwarvenMineWorker&gt; workers; public DwarvenGoldmineFacade() &#123; workers = List.of( new DwarvenGoldDigger(), new DwarvenCartOperator(), new DwarvenTunnelDigger()); &#125; public void startNewDay() &#123; makeActions(workers, DwarvenMineWorker.Action.WAKE_UP, DwarvenMineWorker.Action.GO_TO_MINE); &#125; public void digOutGold() &#123; makeActions(workers, DwarvenMineWorker.Action.WORK); &#125; public void endDay() &#123; makeActions(workers, DwarvenMineWorker.Action.GO_HOME, DwarvenMineWorker.Action.GO_TO_SLEEP); &#125; private static void makeActions(Collection&lt;DwarvenMineWorker&gt; workers, DwarvenMineWorker.Action... actions) &#123; workers.forEach(worker -&gt; worker.action(actions)); &#125;&#125; 现在来使用外观 12345678910111213141516171819DwarvenGoldmineFacade facade = new DwarvenGoldmineFacade();facade.startNewDay();// Dwarf gold digger wakes up.// Dwarf gold digger goes to the mine.// Dwarf cart operator wakes up.// Dwarf cart operator goes to the mine.// Dwarven tunnel digger wakes up.// Dwarven tunnel digger goes to the mine.facade.digOutGold();// Dwarf gold digger digs for gold.// Dwarf cart operator moves gold chunks out of the mine.// Dwarven tunnel digger creates another promising tunnel.facade.endDay();// Dwarf gold digger goes home.// Dwarf gold digger goes to sleep.// Dwarf cart operator goes home.// Dwarf cart operator goes to sleep.// Dwarven tunnel digger goes home.// Dwarven tunnel digger goes to sleep. 类图 适用性使用外观模式当 你想为一个复杂的子系统提供一个简单的接口。随着子系统的发展，它们通常会变得更加复杂。多数模式在应用时会导致更多和更少的类。这使子系统更可重用，更易于自定义，但是对于不需要自定义它的客户来说，使用它也变得更加困难。 外观可以提供子系统的简单默认视图，足以满足大多数客户端的需求。只有需要更多可定制性的客户才需要查看外观外的东西（原子系统提供的接口）。 客户端与抽象的实现类之间存在许多依赖关系。 引入外观以使子系统与客户端和其他子系统分离，从而提高子系统的独立性和可移植性。 您想对子系统进行分层。 使用外观来定义每个子系统级别的入口点。 如果子系统是相关的，则可以通过使子系统仅通过其外观相互通信来简化它们之间的依赖性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Decorator(装饰器模式)","slug":"Decorator","date":"2021-05-29T09:17:20.000Z","updated":"2021-05-29T10:21:49.204Z","comments":true,"path":"2021/05/29/Decorator/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Decorator/","excerpt":"或称包装器 目的动态的为对象附加额外的职责。装饰器为子类提供了灵活的替代方案，以扩展功能。 解释真实世界例子 附近的山丘上住着一个愤怒的巨魔。通常它是徒手的，但有时它有武器。为了武装巨魔不必创建新的巨魔，而是用合适的武器动态的装饰它。 通俗的说 装饰者模式让你可以在运行时通过把对象包装进一个装饰类对象中来动态的改变一个对象的行为。 维基百科说 在面向对象的编程中，装饰器模式是一种设计模式，它允许将行为静态或动态地添加到单个对象中，而不会影响同一类中其他对象的行为。装饰器模式通常对于遵守单一责任原则很有用，因为它允许将功能划分到具有唯一关注领域的类之间。","text":"或称包装器 目的动态的为对象附加额外的职责。装饰器为子类提供了灵活的替代方案，以扩展功能。 解释真实世界例子 附近的山丘上住着一个愤怒的巨魔。通常它是徒手的，但有时它有武器。为了武装巨魔不必创建新的巨魔，而是用合适的武器动态的装饰它。 通俗的说 装饰者模式让你可以在运行时通过把对象包装进一个装饰类对象中来动态的改变一个对象的行为。 维基百科说 在面向对象的编程中，装饰器模式是一种设计模式，它允许将行为静态或动态地添加到单个对象中，而不会影响同一类中其他对象的行为。装饰器模式通常对于遵守单一责任原则很有用，因为它允许将功能划分到具有唯一关注领域的类之间。 程序示例 以巨魔的为例。首先我有有一个简单的巨魔，实现了巨魔接口。 123456789101112131415161718192021222324public interface Troll &#123; void attack(); int getAttackPower(); void fleeBattle();&#125;@Slf4jpublic class SimpleTroll implements Troll &#123; @Override public void attack() &#123; LOGGER.info(&quot;The troll tries to grab you!&quot;); &#125; @Override public int getAttackPower() &#123; return 10; &#125; @Override public void fleeBattle() &#123; LOGGER.info(&quot;The troll shrieks in horror and runs away!&quot;); &#125;&#125; 下面我们想为巨魔添加球棒。我们可以用装饰者来动态的实现。 12345678910111213141516171819202122232425@Slf4jpublic class ClubbedTroll implements Troll &#123; private final Troll decorated; public ClubbedTroll(Troll decorated) &#123; this.decorated = decorated; &#125; @Override public void attack() &#123; decorated.attack(); LOGGER.info(&quot;The troll swings at you with a club!&quot;); &#125; @Override public int getAttackPower() &#123; return decorated.getAttackPower() + 10; &#125; @Override public void fleeBattle() &#123; decorated.fleeBattle(); &#125;&#125; 这里是巨魔的实战 123456789// simple trollvar troll = new SimpleTroll();troll.attack(); // The troll tries to grab you!troll.fleeBattle(); // The troll shrieks in horror and runs away!// change the behavior of the simple troll by adding a decoratorvar clubbedTroll = new ClubbedTroll(troll);clubbedTroll.attack(); // The troll tries to grab you! The troll swings at you with a club!clubbedTroll.fleeBattle(); // The troll shrieks in horror and runs away! 类图 适用性使用装饰者 动态透明地向单个对象添加职责，即不影响其他对象 对于可以撤销的责任 当通过子类化进行扩展是不切实际的。有时可能会有大量的独立扩展，并且会产生大量的子类来支持每种组合。 否则类定义可能被隐藏或无法用于子类化。 教程 Decorator Pattern Tutorial Java世界的例子 java.io.InputStream, java.io.OutputStream, java.io.Reader and java.io.Writer java.util.Collections#synchronizedXXX() java.util.Collections#unmodifiableXXX() java.util.Collections#checkedXXX()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Composite Entity(复合实体模式)","slug":"Composite Entity","date":"2021-05-29T09:14:46.000Z","updated":"2021-05-29T10:21:48.932Z","comments":true,"path":"2021/05/29/Composite Entity/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Composite%20Entity/","excerpt":"含义复合实体模式用于对一组相关联的持久化对象进行建模、描述和管理，用于取代对这组对象描述为单独粒度的实体。 解释现实例子 对于一个控制台对象，需要管理许多接口功能。通过使用复合实体模式，将消息对象、信号对象等依赖性对象组合在一起，直接使用单个对象对其进行控制。 简单地说 复合实体模式允许使用一个统一对象来管理一组相互关联的对象","text":"含义复合实体模式用于对一组相关联的持久化对象进行建模、描述和管理，用于取代对这组对象描述为单独粒度的实体。 解释现实例子 对于一个控制台对象，需要管理许多接口功能。通过使用复合实体模式，将消息对象、信号对象等依赖性对象组合在一起，直接使用单个对象对其进行控制。 简单地说 复合实体模式允许使用一个统一对象来管理一组相互关联的对象 编程示例 我们需要一个通用的解决方案来解决上述的控制台问题。我们引入了以下的通用复合对象。 12345678910111213141516171819202122232425public abstract class DependentObject&lt;T&gt; &#123; T data; public void setData(T message) &#123; this.data = message; &#125; public T getData() &#123; return data; &#125;&#125;public abstract class CoarseGrainedObject&lt;T&gt; &#123; DependentObject&lt;T&gt;[] dependentObjects; public void setData(T... data) &#123; IntStream.range(0, data.length).forEach(i -&gt; dependentObjects[i].setData(data[i])); &#125; public T[] getData() &#123; return (T[]) Arrays.stream(dependentObjects).map(DependentObject::getData).toArray(); &#125;&#125; 专用的 console 复合实体继承自这个基类，如下所示。 123456789101112131415161718192021222324252627282930313233343536public class MessageDependentObject extends DependentObject&lt;String&gt; &#123;&#125;public class SignalDependentObject extends DependentObject&lt;String&gt; &#123;&#125;public class ConsoleCoarseGrainedObject extends CoarseGrainedObject&lt;String&gt; &#123; @Override public String[] getData() &#123; super.getData(); return new String[]&#123; dependentObjects[0].getData(), dependentObjects[1].getData() &#125;; &#125; public void init() &#123; dependentObjects = new DependentObject[]&#123; new MessageDependentObject(), new SignalDependentObject()&#125;; &#125;&#125;public class CompositeEntity &#123; private final ConsoleCoarseGrainedObject console = new ConsoleCoarseGrainedObject(); public void setData(String message, String signal) &#123; console.setData(message, signal); &#125; public String[] getData() &#123; return console.getData(); &#125;&#125; 现在我们使用 console 复合实体来进行消息对象、信号对象的分配。 123456var console = new CompositeEntity();console.init();console.setData(&quot;No Danger&quot;, &quot;Green Light&quot;);Arrays.stream(console.getData()).forEach(LOGGER::info);console.setData(&quot;Danger&quot;, &quot;Red Light&quot;);Arrays.stream(console.getData()).forEach(LOGGER::info); 类图 适用场景复合实体模式适用于以下场景： 你想要通过一个对象来管理多个依赖对象，已调整对象之间的细化程度。同时将依赖对象的生命周期托管到这个粗粒度的复合实体对象。 引用 Composite Entity Pattern in wikipedia","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Composite(组合模式)","slug":"Composite","date":"2021-05-29T08:22:52.000Z","updated":"2021-05-29T10:21:49.628Z","comments":true,"path":"2021/05/29/Composite/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Composite/","excerpt":"目的将对象组合成树结构以表示部分整体层次结构。 组合可以使客户统一对待单个对象和组合对象。 解释真实世界例子 每个句子由单词组成，单词又由字符组成。这些对象中的每一个都是可打印的，它们可以在它们之前或之后打印一些内容，例如句子始终以句号结尾，单词始终在其前面有空格。 通俗的说 组合模式使客户能够以统一的方式对待各个对象。 维基百科说 在软件工程中，组合模式是一种分区设计模式。组合模式中，一组对象将像一个对象的单独实例一样被对待。组合的目的是将对象“组成”树状结构，以表示部分整体层次结构。实现组合模式可使客户统一对待单个对象和组合对象。","text":"目的将对象组合成树结构以表示部分整体层次结构。 组合可以使客户统一对待单个对象和组合对象。 解释真实世界例子 每个句子由单词组成，单词又由字符组成。这些对象中的每一个都是可打印的，它们可以在它们之前或之后打印一些内容，例如句子始终以句号结尾，单词始终在其前面有空格。 通俗的说 组合模式使客户能够以统一的方式对待各个对象。 维基百科说 在软件工程中，组合模式是一种分区设计模式。组合模式中，一组对象将像一个对象的单独实例一样被对待。组合的目的是将对象“组成”树状结构，以表示部分整体层次结构。实现组合模式可使客户统一对待单个对象和组合对象。 程序示例 使用上面的句子例子。 这里我们有基类LetterComposite和不同的可打印类型Letter，Word和Sentence。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public abstract class LetterComposite &#123; private final List&lt;LetterComposite&gt; children = new ArrayList&lt;&gt;(); public void add(LetterComposite letter) &#123; children.add(letter); &#125; public int count() &#123; return children.size(); &#125; protected void printThisBefore() &#123; &#125; protected void printThisAfter() &#123; &#125; public void print() &#123; printThisBefore(); children.forEach(LetterComposite::print); printThisAfter(); &#125;&#125;public class Letter extends LetterComposite &#123; private final char character; public Letter(char c) &#123; this.character = c; &#125; @Override protected void printThisBefore() &#123; System.out.print(character); &#125;&#125;public class Word extends LetterComposite &#123; public Word(List&lt;Letter&gt; letters) &#123; letters.forEach(this::add); &#125; public Word(char... letters) &#123; for (char letter : letters) &#123; this.add(new Letter(letter)); &#125; &#125; @Override protected void printThisBefore() &#123; System.out.print(&quot; &quot;); &#125;&#125;public class Sentence extends LetterComposite &#123; public Sentence(List&lt;Word&gt; words) &#123; words.forEach(this::add); &#125; @Override protected void printThisAfter() &#123; System.out.print(&quot;.&quot;); &#125;&#125; 然后我们有一个消息携带者来携带消息。 123456789101112131415161718192021222324252627282930313233343536public class Messenger &#123; LetterComposite messageFromOrcs() &#123; var words = List.of( new Word(&#x27;W&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;e&#x27;), new Word(&#x27;t&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;e&#x27;), new Word(&#x27;i&#x27;, &#x27;s&#x27;), new Word(&#x27;a&#x27;), new Word(&#x27;w&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;p&#x27;), new Word(&#x27;t&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;e&#x27;), new Word(&#x27;i&#x27;, &#x27;s&#x27;), new Word(&#x27;a&#x27;), new Word(&#x27;w&#x27;, &#x27;a&#x27;, &#x27;y&#x27;) ); return new Sentence(words); &#125; LetterComposite messageFromElves() &#123; var words = List.of( new Word(&#x27;M&#x27;, &#x27;u&#x27;, &#x27;c&#x27;, &#x27;h&#x27;), new Word(&#x27;w&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;d&#x27;), new Word(&#x27;p&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;r&#x27;, &#x27;s&#x27;), new Word(&#x27;f&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;m&#x27;), new Word(&#x27;y&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;r&#x27;), new Word(&#x27;m&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;t&#x27;, &#x27;h&#x27;) ); return new Sentence(words); &#125;&#125; 然后它可以这样使用: 1234var orcMessage = new Messenger().messageFromOrcs();orcMessage.print(); // Where there is a whip there is a way.var elfMessage = new Messenger().messageFromElves();elfMessage.print(); // Much wind pours from your mouth. 类图[ 适用性使用组合模式当 你想要表示对象的整体层次结构 你希望客户能够忽略组合对象和单个对象之间的差异。 客户将统一对待组合结构中的所有对象。 真实世界例子 java.awt.Container and java.awt.Component Apache Wicket component tree, see Component and MarkupContainer","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Filter (过滤器模式)|Criteria(标准模式)","slug":"Filter","date":"2021-05-29T08:08:16.000Z","updated":"2021-05-29T10:49:04.085Z","comments":true,"path":"2021/05/29/Filter/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Filter/","excerpt":"又被称为过滤器|标准模式 目的这种设计模式的目的是引入一个功能接口，该接口将为类似容器的对象添加一个功能，以便轻松返回它们自身的过滤版本。 解释真实世界例子 我们正在设计一种威胁（恶意软件）检测软件，它可以分析目标系统中存在的威胁。 在设计中，我们必须考虑到以后可以添加新的威胁类型。 此外，还要求威胁检测系统可以根据不同的标准过滤检测到的威胁（目标系统充当威胁的容器类对象）。 通俗的说 过滤器模式是一种设计模式，可帮助类容器对象返回自身的过滤版本。","text":"又被称为过滤器|标准模式 目的这种设计模式的目的是引入一个功能接口，该接口将为类似容器的对象添加一个功能，以便轻松返回它们自身的过滤版本。 解释真实世界例子 我们正在设计一种威胁（恶意软件）检测软件，它可以分析目标系统中存在的威胁。 在设计中，我们必须考虑到以后可以添加新的威胁类型。 此外，还要求威胁检测系统可以根据不同的标准过滤检测到的威胁（目标系统充当威胁的容器类对象）。 通俗的说 过滤器模式是一种设计模式，可帮助类容器对象返回自身的过滤版本。 程序示例 为了对上述威胁检测示例进行建模，我们引入了“Threat”和“ThreatAwareSystem”接口。 123456789101112public interface Threat &#123; String name(); int id(); ThreatType type();&#125;public interface ThreatAwareSystem &#123; String systemId(); List&lt;? extends Threat&gt; threats(); Filterer&lt;? extends ThreatAwareSystem, ? extends Threat&gt; filtered();&#125; 请注意返回“Filterer”接口实例的“filtered”方法，该方法定义为： 1234@FunctionalInterfacepublic interface Filterer&lt;G, E&gt; &#123; G by(Predicate&lt;? super E&gt; predicate);&#125; 它用于满足系统能够根据威胁属性过滤自身的要求。 类似于容器的对象（在本例中为“ ThreatAwareSystem”）需要有一个返回“ Filterer”实例的方法。 这个辅助接口提供了在表示类容器对象的接口的子接口中协变指定逆变Predicate的下界的能力。 在我们的示例中，我们将能够传递一个带有 ? 扩展 Threat 对象并返回 ? 从 Filtered::by 方法扩展 ThreatAwareSystem。 ThreatAwareSystem 的简单实现： 1234567891011121314151617181920212223242526272829303132333435public class SimpleThreatAwareSystem implements ThreatAwareSystem &#123; private final String systemId; private final ImmutableList&lt;Threat&gt; issues; public SimpleThreatAwareSystem(final String systemId, final List&lt;Threat&gt; issues) &#123; this.systemId = systemId; this.issues = ImmutableList.copyOf(issues); &#125; @Override public String systemId() &#123; return systemId; &#125; @Override public List&lt;? extends Threat&gt; threats() &#123; return new ArrayList&lt;&gt;(issues); &#125; @Override public Filterer&lt;? extends ThreatAwareSystem, ? extends Threat&gt; filtered() &#123; return this::filteredGroup; &#125; private ThreatAwareSystem filteredGroup(Predicate&lt;? super Threat&gt; predicate) &#123; return new SimpleThreatAwareSystem(this.systemId, filteredItems(predicate)); &#125; private List&lt;Threat&gt; filteredItems(Predicate&lt;? super Threat&gt; predicate) &#123; return this.issues.stream() .filter(predicate) .collect(Collectors.toList()); &#125;&#125; filtered 方法被重写以通过给定的谓词过滤威胁列表。 现在，如果我们引入一个新的“威胁”接口子类型，它增加了给定威胁出现的概率： 123public interface ProbableThreat extends Threat &#123; double probability();&#125; 我们还可以引入一个新接口，该接口代表一个系统，该系统通过其概率感知威胁： 1234567public interface ProbabilisticThreatAwareSystem extends ThreatAwareSystem &#123; @Override List&lt;? extends ProbableThreat&gt; threats(); @Override Filterer&lt;? extends ProbabilisticThreatAwareSystem, ? extends ProbableThreat&gt; filtered();&#125; 请注意我们如何覆盖 ProbabilisticThreatAwareSystem 中的 filtered 方法并通过指定不同的泛型类型来指定不同的返回协变类型。 我们的界面是干净的，默认实现不会混乱。 我们将能够通过“ProbableThreat”属性过滤“ProbabilisticThreatAwareSystem”： 1234567891011121314151617181920212223242526272829303132333435public class SimpleProbabilisticThreatAwareSystem implements ProbabilisticThreatAwareSystem &#123; private final String systemId; private final ImmutableList&lt;ProbableThreat&gt; threats; public SimpleProbabilisticThreatAwareSystem(final String systemId, final List&lt;ProbableThreat&gt; threats) &#123; this.systemId = systemId; this.threats = ImmutableList.copyOf(threats); &#125; @Override public String systemId() &#123; return systemId; &#125; @Override public List&lt;? extends ProbableThreat&gt; threats() &#123; return threats; &#125; @Override public Filterer&lt;? extends ProbabilisticThreatAwareSystem, ? extends ProbableThreat&gt; filtered() &#123; return this::filteredGroup; &#125; private ProbabilisticThreatAwareSystem filteredGroup(final Predicate&lt;? super ProbableThreat&gt; predicate) &#123; return new SimpleProbabilisticThreatAwareSystem(this.systemId, filteredItems(predicate)); &#125; private List&lt;ProbableThreat&gt; filteredItems(final Predicate&lt;? super ProbableThreat&gt; predicate) &#123; return this.threats.stream() .filter(predicate) .collect(Collectors.toList()); &#125;&#125; 现在，如果我们想按威胁类型过滤“ThreatAwareSystem”，我们可以这样做： 12345678Threat rootkit = new SimpleThreat(ThreatType.ROOTKIT, 1, &quot;Simple-Rootkit&quot;);Threat trojan = new SimpleThreat(ThreatType.TROJAN, 2, &quot;Simple-Trojan&quot;);List&lt;Threat&gt; threats = List.of(rootkit, trojan);ThreatAwareSystem threatAwareSystem = new SimpleThreatAwareSystem(&quot;System-1&quot;, threats);ThreatAwareSystem rootkitThreatAwareSystem = threatAwareSystem.filtered() .by(threat -&gt; threat.type() == ThreatType.ROOTKIT); 或者，如果我们想过滤 ProbabilisticThreatAwareSystem： 12345678ProbableThreat malwareTroyan = new SimpleProbableThreat(&quot;Troyan-ArcBomb&quot;, 1, ThreatType.TROJAN, 0.99);ProbableThreat rootkit = new SimpleProbableThreat(&quot;Rootkit-System&quot;, 2, ThreatType.ROOTKIT, 0.8);List&lt;ProbableThreat&gt; probableThreats = List.of(malwareTroyan, rootkit);ProbabilisticThreatAwareSystem simpleProbabilisticThreatAwareSystem =new SimpleProbabilisticThreatAwareSystem(&quot;System-1&quot;, probableThreats);ProbabilisticThreatAwareSystem filtered = simpleProbabilisticThreatAwareSystem.filtered() .by(probableThreat -&gt; Double.compare(probableThreat.probability(), 0.99) == 0); 类图[ 适用性当处理使用子类型的容器类对象时，可以使用模式，而不是对可扩展类结构进行参数化（泛型）。 随着业务需求的变化，它使您可以轻松地扩展类似容器的对象的过滤功能。 教程 Article about Filterer pattern posted on it’s author’s blog Application of Filterer pattern in domain of text analysis Java世界使用 这条 链接中的博客中提供了一种用途。 它介绍了如何使用“过滤器”模式来创建支持用于单元测试的测试用例的文本问题分析器。 后果优点： 您可以轻松地为类容器对象引入新的子类型，并为包含在其中的对象引入子类型，并且仍然能够轻松过滤这些新子类型的新属性。 缺点： 与泛型混合的协变返回类型有时会很棘手","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Bridge (桥接模式)","slug":"Bridge","date":"2021-05-29T08:04:05.000Z","updated":"2021-05-29T10:21:49.413Z","comments":true,"path":"2021/05/29/Bridge/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Bridge/","excerpt":"又被称为手柄/身体模式 目的将抽象与其实现分离，以便二者可以独立变化。 解释真实世界例子 考虑一下你拥有一种具有不同附魔的武器，并且应该允许将具有不同附魔的不同武器混合使用。 你会怎么做？ 为每个附魔创建每种武器的多个副本，还是只是创建单独的附魔并根据需要为武器设置它？ 桥接模式使您可以进行第二次操作。 通俗的说 桥接模式是一个更推荐组合而不是继承的模式。将实现细节从一个层次结构推送到具有单独层次结构的另一个对象。 维基百科说 桥接模式是软件工程中使用的一种设计模式，旨在“将抽象与其实现分离，从而使两者可以独立变化”","text":"又被称为手柄/身体模式 目的将抽象与其实现分离，以便二者可以独立变化。 解释真实世界例子 考虑一下你拥有一种具有不同附魔的武器，并且应该允许将具有不同附魔的不同武器混合使用。 你会怎么做？ 为每个附魔创建每种武器的多个副本，还是只是创建单独的附魔并根据需要为武器设置它？ 桥接模式使您可以进行第二次操作。 通俗的说 桥接模式是一个更推荐组合而不是继承的模式。将实现细节从一个层次结构推送到具有单独层次结构的另一个对象。 维基百科说 桥接模式是软件工程中使用的一种设计模式，旨在“将抽象与其实现分离，从而使两者可以独立变化” 程序示例 翻译一下上面的武器示例。下面我们有武器的类层级： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface Weapon &#123; void wield(); void swing(); void unwield(); Enchantment getEnchantment();&#125;public class Sword implements Weapon &#123; private final Enchantment enchantment; public Sword(Enchantment enchantment) &#123; this.enchantment = enchantment; &#125; @Override public void wield() &#123; LOGGER.info(&quot;The sword is wielded.&quot;); enchantment.onActivate(); &#125; @Override public void swing() &#123; LOGGER.info(&quot;The sword is swinged.&quot;); enchantment.apply(); &#125; @Override public void unwield() &#123; LOGGER.info(&quot;The sword is unwielded.&quot;); enchantment.onDeactivate(); &#125; @Override public Enchantment getEnchantment() &#123; return enchantment; &#125;&#125;public class Hammer implements Weapon &#123; private final Enchantment enchantment; public Hammer(Enchantment enchantment) &#123; this.enchantment = enchantment; &#125; @Override public void wield() &#123; LOGGER.info(&quot;The hammer is wielded.&quot;); enchantment.onActivate(); &#125; @Override public void swing() &#123; LOGGER.info(&quot;The hammer is swinged.&quot;); enchantment.apply(); &#125; @Override public void unwield() &#123; LOGGER.info(&quot;The hammer is unwielded.&quot;); enchantment.onDeactivate(); &#125; @Override public Enchantment getEnchantment() &#123; return enchantment; &#125;&#125; 这里是单独的附魔类结构： 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Enchantment &#123; void onActivate(); void apply(); void onDeactivate();&#125;public class FlyingEnchantment implements Enchantment &#123; @Override public void onActivate() &#123; LOGGER.info(&quot;The item begins to glow faintly.&quot;); &#125; @Override public void apply() &#123; LOGGER.info(&quot;The item flies and strikes the enemies finally returning to owner&#x27;s hand.&quot;); &#125; @Override public void onDeactivate() &#123; LOGGER.info(&quot;The item&#x27;s glow fades.&quot;); &#125;&#125;public class SoulEatingEnchantment implements Enchantment &#123; @Override public void onActivate() &#123; LOGGER.info(&quot;The item spreads bloodlust.&quot;); &#125; @Override public void apply() &#123; LOGGER.info(&quot;The item eats the soul of enemies.&quot;); &#125; @Override public void onDeactivate() &#123; LOGGER.info(&quot;Bloodlust slowly disappears.&quot;); &#125;&#125; 这里是两种层次结构的实践： 123456789101112131415161718192021var enchantedSword = new Sword(new SoulEatingEnchantment());enchantedSword.wield();enchantedSword.swing();enchantedSword.unwield();// The sword is wielded.// The item spreads bloodlust.// The sword is swinged.// The item eats the soul of enemies.// The sword is unwielded.// Bloodlust slowly disappears.var hammer = new Hammer(new FlyingEnchantment());hammer.wield();hammer.swing();hammer.unwield();// The hammer is wielded.// The item begins to glow faintly.// The hammer is swinged.// The item flies and strikes the enemies finally returning to owner&#x27;s hand.// The hammer is unwielded.// The item&#x27;s glow fades. 类图[ 适用性使用桥接模式当 你想永久性的避免抽象和他的实现之间的绑定。有可能是这种情况，当实现需要被选择或者在运行时切换。 抽象和他们的实现应该能通过写子类来扩展。这种情况下，桥接模式让你可以组合不同的抽象和实现并独立的扩展他们。 对抽象的实现的改动应当不会对客户产生影响；也就是说，他们的代码不必重新编译。 你有种类繁多的类。这样的类层次结构表明需要将一个对象分为两部分。Rumbaugh 使用术语“嵌套归纳”来指代这种类层次结构。 你想在多个对象间分享一种实现（可能使用引用计数），这个事实应该对客户隐藏。一个简单的示例是Coplien的String类，其中多个对象可以共享同一字符串表示形式 教程 Bridge Pattern Tutorial","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Adapter(适配器模式)","slug":"Adapter","date":"2021-05-29T08:02:08.000Z","updated":"2021-05-29T10:21:49.272Z","comments":true,"path":"2021/05/29/Adapter/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Adapter/","excerpt":"又被称为包装器 目的将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。 解释现实世界例子 考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。 用直白的话来说 适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。 维基百科中说 在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。","text":"又被称为包装器 目的将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。 解释现实世界例子 考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。 用直白的话来说 适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。 维基百科中说 在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。 编程样例(对象适配器) 假如有一个船长他只会划船，但不会航行。 首先我们有接口RowingBoat和FishingBoat 12345678910public interface RowingBoat &#123; void row();&#125;@Slf4jpublic class FishingBoat &#123; public void sail() &#123; LOGGER.info(&quot;The fishing boat is sailing&quot;); &#125;&#125; 船长希望有一个RowingBoat接口的实现，这样就可以移动 123456789101112public class Captain &#123; private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) &#123; this.rowingBoat = rowingBoat; &#125; public void row() &#123; rowingBoat.row(); &#125;&#125; 现在海盗来了，我们的船长需要逃跑但是只有一个渔船可用。我们需要创建一个可以让船长使用其划船技能来操作渔船的适配器。 1234567891011121314@Slf4jpublic class FishingBoatAdapter implements RowingBoat &#123; private final FishingBoat boat; public FishingBoatAdapter() &#123; boat = new FishingBoat(); &#125; @Override public void row() &#123; boat.sail(); &#125;&#125; 现在 船长 可以使用FishingBoat接口来逃离海盗了。 12var captain = new Captain(new FishingBoatAdapter());captain.row(); 类图[ 应用使用适配器模式当 你想使用一个已有类，但是它的接口不能和你需要的所匹配 你需要创建一个可重用类，该类与不相关或不可预见的类进行协作，即不一定具有兼容接口的类 你需要使用一些现有的子类，但是子类化他们每一个的子类来进行接口的适配是不现实的。一个对象适配器可以适配他们父类的接口。 大多数使用第三方类库的应用使用适配器作为一个在应用和第三方类库间的中间层来使应用和类库解耦。如果必须使用另一个库，则只需使用一个新库的适配器而无需改变应用程序的代码。 后果:类和对象适配器有不同的权衡取舍。一个类适配器 适配被适配者到目标接口，需要保证只有一个具体的被适配者类。作为结果，当我们想适配一个类和它所有的子类时，类适配器将不会起作用。 可以让适配器重写一些被适配者的行为，因为适配器是被适配者的子类。 只引入了一个对象，并且不需要其他指针间接访问被适配者。 对象适配器 一个适配器可以和许多被适配者工作，也就是被适配者自己和所有它的子类。适配器同时可以为所有被适配者添加功能。 覆盖被适配者的行为变得更难。需要子类化被适配者然后让适配器引用这个子类不是被适配者。 现实世界的案例 java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Prototype (原型模式)","slug":"Prototype","date":"2021-05-29T07:53:57.000Z","updated":"2021-05-29T10:49:04.266Z","comments":true,"path":"2021/05/29/Prototype/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Prototype/","excerpt":"目的使用原型实例指定要创建的对象种类，并通过复制此原型来创建新对象。 解释首先应该注意的是，原型模式不是为了获得性能优势。 它仅用于从原型实例创建新对象。 真实世界例子 还记得多莉吗？ 被克隆的羊！ 让我们不要进入细节，但这里的关键点是这一切都与克隆有关。 通俗的说 通过克隆基于现有对象创建对象。 维基百科上说 原型模式是软件开发中的一种创建性设计模式。 当要创建的对象类型由原型实例确定时使用，该实例被克隆以生成新对象。 简而言之，它允许您创建现有对象的副本并根据需要对其进行修改，而不是从头开始创建对象并进行设置。","text":"目的使用原型实例指定要创建的对象种类，并通过复制此原型来创建新对象。 解释首先应该注意的是，原型模式不是为了获得性能优势。 它仅用于从原型实例创建新对象。 真实世界例子 还记得多莉吗？ 被克隆的羊！ 让我们不要进入细节，但这里的关键点是这一切都与克隆有关。 通俗的说 通过克隆基于现有对象创建对象。 维基百科上说 原型模式是软件开发中的一种创建性设计模式。 当要创建的对象类型由原型实例确定时使用，该实例被克隆以生成新对象。 简而言之，它允许您创建现有对象的副本并根据需要对其进行修改，而不是从头开始创建对象并进行设置。 程序示例 在 Java 中，可以通过实现 Cloneable 并从 Object 覆盖 clone 来轻松完成 1234567891011121314class Sheep implements Cloneable &#123; private String name; public Sheep(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; @Override public Sheep clone() &#123; try &#123; return (Sheep)super.clone(); &#125; catch(CloneNotSuportedException) &#123; throw new InternalError(); &#125; &#125;&#125; 然后它可以像下面这样克隆: 1234567var original = new Sheep(&quot;Jolly&quot;);System.out.println(original.getName()); // Jolly// Clone and modify what is requiredvar cloned = original.clone();cloned.setName(&quot;Dolly&quot;);System.out.println(cloned.getName()); // Dolly 类图[ 适用性当系统应该独立于其产品的创建、组合、表示和表示方式时，使用原型模式 在运行时指定要实例化的类时，例如，通过动态加载。 避免构建与产品类层次结构平行的工厂类层次结构。 当一个类的实例可以具有仅有的几种不同状态组合中的一种时。 安装相应数量的原型并克隆它们可能更方便，而不是每次都使用适当的状态手动实例化类。 与克隆相比，创建对象的成本更高。 Java世界使用 java.lang.Object#clone()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Builder(建造者模式)","slug":"Builder","date":"2021-05-29T07:51:08.000Z","updated":"2021-05-29T10:21:49.560Z","comments":true,"path":"2021/05/29/Builder/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Builder/","excerpt":"目的将复杂对象的构造与其表示分开，以便同一构造过程可以创建不同的表示。 解释现实世界例子 想象一个角色扮演游戏的角色生成器。最简单的选择是让计算机为你创建角色。但是如果你想选择一些像专业，性别，发色等角色细节时，这个角色生成就变成了一个渐进的过程。当所有选择完成时，该过程也将完成。 用通俗的话说 允许你创建不同口味的对象同时避免构造器污染。当一个对象可能有几种口味，或者一个对象的创建涉及到很多步骤时会很有用。 维基百科说 建造者模式是一种对象创建的软件设计模式，旨在为伸缩构造器反模式寻找一个解决方案。 说了这么多，让我补充一下什么是伸缩构造函数反模式。我们肯定都见过像下面这样的构造器： 12public Hero(Profession profession, String name, HairType hairType, HairColor hairColor, Armor armor, Weapon weapon) &#123;&#125; 就像你看到的构造器参数的数量很快就会失控同时参数的排列方式可能变得难以理解。另外，如果您将来希望添加更多选项，则此参数列表可能会继续增长。这就被称伸缩构造器反模式。","text":"目的将复杂对象的构造与其表示分开，以便同一构造过程可以创建不同的表示。 解释现实世界例子 想象一个角色扮演游戏的角色生成器。最简单的选择是让计算机为你创建角色。但是如果你想选择一些像专业，性别，发色等角色细节时，这个角色生成就变成了一个渐进的过程。当所有选择完成时，该过程也将完成。 用通俗的话说 允许你创建不同口味的对象同时避免构造器污染。当一个对象可能有几种口味，或者一个对象的创建涉及到很多步骤时会很有用。 维基百科说 建造者模式是一种对象创建的软件设计模式，旨在为伸缩构造器反模式寻找一个解决方案。 说了这么多，让我补充一下什么是伸缩构造函数反模式。我们肯定都见过像下面这样的构造器： 12public Hero(Profession profession, String name, HairType hairType, HairColor hairColor, Armor armor, Weapon weapon) &#123;&#125; 就像你看到的构造器参数的数量很快就会失控同时参数的排列方式可能变得难以理解。另外，如果您将来希望添加更多选项，则此参数列表可能会继续增长。这就被称伸缩构造器反模式。 编程示例 明智的选择是使用建造者模式。首先我们有一个英雄要创建。 1234567891011121314151617public final class Hero &#123; private final Profession profession; private final String name; private final HairType hairType; private final HairColor hairColor; private final Armor armor; private final Weapon weapon; private Hero(Builder builder) &#123; this.profession = builder.profession; this.name = builder.name; this.hairColor = builder.hairColor; this.hairType = builder.hairType; this.weapon = builder.weapon; this.armor = builder.armor; &#125;&#125; 然后我们有创建者 12345678910111213141516171819202122232425262728293031323334353637383940public static class Builder &#123; private final Profession profession; private final String name; private HairType hairType; private HairColor hairColor; private Armor armor; private Weapon weapon; public Builder(Profession profession, String name) &#123; if (profession == null || name == null) &#123; throw new IllegalArgumentException(&quot;profession and name can not be null&quot;); &#125; this.profession = profession; this.name = name; &#125; public Builder withHairType(HairType hairType) &#123; this.hairType = hairType; return this; &#125; public Builder withHairColor(HairColor hairColor) &#123; this.hairColor = hairColor; return this; &#125; public Builder withArmor(Armor armor) &#123; this.armor = armor; return this; &#125; public Builder withWeapon(Weapon weapon) &#123; this.weapon = weapon; return this; &#125; public Hero build() &#123; return new Hero(this); &#125;&#125; 然后可以这样使用 1var mage = new Hero.Builder(Profession.MAGE, &quot;Riobard&quot;).withHairColor(HairColor.BLACK).withWeapon(Weapon.DAGGER).build(); 类图[ 适用性使用建造者模式当 创建复杂对象的算法应独立于组成对象的零件及其组装方式 构造过程必须允许所构造的对象具有不同的表示形式 Java世界例子 java.lang.StringBuilder java.nio.ByteBuffer as well as similar buffers such as FloatBuffer, IntBuffer and so on. java.lang.StringBuffer All implementations of java.lang.Appendable Apache Camel builders Apache Commons Option.Builder","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Singleton(单例模式)","slug":"Singleton","date":"2021-05-29T07:35:06.000Z","updated":"2021-05-29T10:49:04.378Z","comments":true,"path":"2021/05/29/Singleton/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Singleton/","excerpt":"目的确保一个类只有一个实例，并提供对它的全局访问点。 解释真实世界例子 只有一座魔法学校可供巫师学习魔法。 巫师们总是使用同一个魔法学校来学习。 这里的魔法学校就是单例。 通俗的说 确保只创建特定类的一个对象。 维基百科上说 在软件工程中，单例模式是一种软件设计模式，它将类的实例化限制为一个对象。 当只需要一个对象来协调整个系统的操作时，这很有用。","text":"目的确保一个类只有一个实例，并提供对它的全局访问点。 解释真实世界例子 只有一座魔法学校可供巫师学习魔法。 巫师们总是使用同一个魔法学校来学习。 这里的魔法学校就是单例。 通俗的说 确保只创建特定类的一个对象。 维基百科上说 在软件工程中，单例模式是一种软件设计模式，它将类的实例化限制为一个对象。 当只需要一个对象来协调整个系统的操作时，这很有用。 程序示例 Joshua Bloch《Effective Java》 第二版第18章节 单元素枚举类型是实现单例的最佳方式 123public enum EnumIvoryTower &#123; INSTANCE&#125; 然后是使用: 123var enumIvoryTower1 = EnumIvoryTower.INSTANCE;var enumIvoryTower2 = EnumIvoryTower.INSTANCE;assertEquals(enumIvoryTower1, enumIvoryTower2); // true 类图 在以下情况下使用单例模式 必须只有一个类的实例，并且客户端必须可以从众所周知的访问点访问它 当唯一的实例应该可以通过子类化扩展，并且客户端应该能够使用扩展的实例而无需修改他们的代码 示例场景 日志记录类 管理与数据库的连接 文件管理器 Java世界使用 java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 后果 通过控制自己的创建和生命周期来违反单一职责原则 (SRP)。 鼓励使用全局共享实例，以防止释放该对象使用的对象和资源。 创建紧密耦合的代码。 Singleton 的客户端变得难以测试。 几乎不可能对单例进行子类化。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Abstract Factory(抽象工厂模式)","slug":"Abstract Factory","date":"2021-05-29T07:23:21.000Z","updated":"2021-05-29T10:49:04.337Z","comments":true,"path":"2021/05/29/Abstract Factory/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Abstract%20Factory/","excerpt":"或称工具包 目的提供一个用于创建相关对象家族的接口，而无需指定其具体类。 解释真实世界例子 要创建一个王国，我们需要具有共同主题的对象。 精灵王国需要精灵王，精灵城堡和精灵军队，而兽人王国需要兽王，精灵城堡和兽人军队。 王国中的对象之间存在依赖性。 通俗的说 工厂的工厂； 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。 维基百科上说 抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法","text":"或称工具包 目的提供一个用于创建相关对象家族的接口，而无需指定其具体类。 解释真实世界例子 要创建一个王国，我们需要具有共同主题的对象。 精灵王国需要精灵王，精灵城堡和精灵军队，而兽人王国需要兽王，精灵城堡和兽人军队。 王国中的对象之间存在依赖性。 通俗的说 工厂的工厂； 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。 维基百科上说 抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法 程序示例 翻译上面的王国示例。 首先，我们为王国中的对象提供了一些接口和实现。 12345678910111213141516171819202122232425262728293031323334353637public interface Castle &#123; String getDescription();&#125;public interface King &#123; String getDescription();&#125;public interface Army &#123; String getDescription();&#125;// Elven implementations -&gt;public class ElfCastle implements Castle &#123; static final String DESCRIPTION = &quot;This is the Elven castle!&quot;; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;public class ElfKing implements King &#123; static final String DESCRIPTION = &quot;This is the Elven king!&quot;; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;public class ElfArmy implements Army &#123; static final String DESCRIPTION = &quot;This is the Elven Army!&quot;; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;// Orcish implementations similarly -&gt; ... 然后我们有了王国工厂的抽象和实现 1234567891011121314151617181920212223242526272829public interface KingdomFactory &#123; Castle createCastle(); King createKing(); Army createArmy();&#125;public class ElfKingdomFactory implements KingdomFactory &#123; public Castle createCastle() &#123; return new ElfCastle(); &#125; public King createKing() &#123; return new ElfKing(); &#125; public Army createArmy() &#123; return new ElfArmy(); &#125;&#125;public class OrcKingdomFactory implements KingdomFactory &#123; public Castle createCastle() &#123; return new OrcCastle(); &#125; public King createKing() &#123; return new OrcKing(); &#125; public Army createArmy() &#123; return new OrcArmy(); &#125;&#125; 现在我们有了抽象工厂，使我们可以制作相关对象的系列，即精灵王国工厂创建了精灵城堡，国王和军队等。 12345678var factory = new ElfKingdomFactory();var castle = factory.createCastle();var king = factory.createKing();var army = factory.createArmy();castle.getDescription();king.getDescription();army.getDescription(); 程序输出: 123This is the Elven castle!This is the Elven king!This is the Elven Army! 现在，我们可以为不同的王国工厂设计工厂。 在此示例中，我们创建了FactoryMaker，负责返回ElfKingdomFactory或OrcKingdomFactory的实例。 客户可以使用FactoryMaker来创建所需的具体工厂，该工厂随后将生产不同的具体对象（军队，国王，城堡）。 在此示例中，我们还使用了一个枚举来参数化客户要求的王国工厂类型。 12345678910111213141516171819202122232425262728293031public static class FactoryMaker &#123; public enum KingdomType &#123; ELF, ORC &#125; public static KingdomFactory makeFactory(KingdomType type) &#123; switch (type) &#123; case ELF: return new ElfKingdomFactory(); case ORC: return new OrcKingdomFactory(); default: throw new IllegalArgumentException(&quot;KingdomType not supported.&quot;); &#125; &#125;&#125;public static void main(String[] args) &#123; var app = new App(); LOGGER.info(&quot;Elf Kingdom&quot;); app.createKingdom(FactoryMaker.makeFactory(KingdomType.ELF)); LOGGER.info(app.getArmy().getDescription()); LOGGER.info(app.getCastle().getDescription()); LOGGER.info(app.getKing().getDescription()); LOGGER.info(&quot;Orc Kingdom&quot;); app.createKingdom(FactoryMaker.makeFactory(KingdomType.ORC)); -- similar use of the orc factory&#125; 类图 适用性在以下情况下使用抽象工厂模式 该系统应独立于其产品的创建，组成和表示方式 系统应配置有多个产品系列之一 相关产品对象系列旨在一起使用，你需要强制执行此约束 你想提供产品的类库，并且只想暴露它们的接口，而不是它们的实现。 从概念上讲，依赖项的生存期比使用者的生存期短。 你需要一个运行时值来构建特定的依赖关系 你想决定在运行时从系列中调用哪种产品。 你需要提供一个或更多仅在运行时才知道的参数，然后才能解决依赖关系。 当你需要产品之间的一致性时 在向程序添加新产品或产品系列时，您不想更改现有代码。 示例场景 在运行时在FileSystemAcmeService ，DatabaseAcmeService 或NetworkAcmeService中选择并调用一个 单元测试用例的编写变得更加容易 适用于不同操作系统的UI工具 后果: Java中的依赖注入会隐藏服务类的依赖关系，这些依赖关系可能导致运行时错误，而这些错误在编译时会被捕获。 虽然在创建预定义对象时模式很好，但是添加新对象可能会很困难。 由于引入了许多新的接口和类，因此代码变得比应有的复杂。 教程 Abstract Factory Pattern Tutorial Java世界使用 javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory 相关模式 Factory Method Factory Kit","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Factory(工厂模式)","slug":"Factory","date":"2021-05-29T02:30:03.000Z","updated":"2021-05-29T15:16:40.813Z","comments":true,"path":"2021/05/29/Factory/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/Factory/","excerpt":"也被称为 简单工厂 静态工厂方法 含义在工厂类中提供一个封装的静态工厂方法，用于隐藏对象初始化细节，使客户端代码可以专注于使用，而不用关心类的初始化过程。 解释现实例子 假设我们有一个需要连接到 SQL Server 的 Web 应用，但现在我们需要切换到连接 Oracle。为了不修改现有代码的情况下做到这一点，我们需要实现简单工厂模式。在这种模式下，可以通过调用一个静态方法来创建与给定数据库的连接。 维基百科 工厂类是一个用于创建其他对象的对象 – 从形式上看，工厂方法是一个用于返回不同原型或类型的函数或方法。","text":"也被称为 简单工厂 静态工厂方法 含义在工厂类中提供一个封装的静态工厂方法，用于隐藏对象初始化细节，使客户端代码可以专注于使用，而不用关心类的初始化过程。 解释现实例子 假设我们有一个需要连接到 SQL Server 的 Web 应用，但现在我们需要切换到连接 Oracle。为了不修改现有代码的情况下做到这一点，我们需要实现简单工厂模式。在这种模式下，可以通过调用一个静态方法来创建与给定数据库的连接。 维基百科 工厂类是一个用于创建其他对象的对象 – 从形式上看，工厂方法是一个用于返回不同原型或类型的函数或方法。 编程示例 我们有一个 Car 接口，以及实现类 Ford, Ferrari。 1234567891011121314151617181920212223public interface Car &#123; String getDescription();&#125;public class Ford implements Car &#123; static final String DESCRIPTION = &quot;This is Ford.&quot;; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125;public class Ferrari implements Car &#123; static final String DESCRIPTION = &quot;This is Ferrari.&quot;; @Override public String getDescription() &#123; return DESCRIPTION; &#125;&#125; Enumeration above represents types of cars that we support (Ford and Ferrari). 以下的枚举用于表示支持的 Car 类型（Ford 和 Ferrari） 123456789101112131415public enum CarType &#123; FORD(Ford::new), FERRARI(Ferrari::new); private final Supplier&lt;Car&gt; constructor; CarType(Supplier&lt;Car&gt; constructor) &#123; this.constructor = constructor; &#125; public Supplier&lt;Car&gt; getConstructor() &#123; return this.constructor; &#125;&#125; 接着我们实现了一个静态方法 getCar 用于封装工厂类 CarsFactory 创建 Car 具体对象实例的细节。 123456public class CarsFactory &#123; public static Car getCar(CarType type) &#123; return type.getConstructor().get(); &#125;&#125; 现在我们可以在客户端代码中通过工厂类创建不同类型的 Car 对象实例。 1234var car1 = CarsFactory.getCar(CarType.FORD);var car2 = CarsFactory.getCar(CarType.FERRARI);LOGGER.info(car1.getDescription());LOGGER.info(car2.getDescription()); 程序输出： 12This is Ford.This is Ferrari. 类图 适用场景在你只关心对象的创建，但不关心如何创建、管理它的时候，请使用简单工厂模式。 优点 可以把对象创建代码集中在一个地方，避免在代码库存散布 “new” 关键字。 可以让代码更加低耦合。它的一些主要优点包括更好的可测试性、更好的可读性、组件可替换性、可拓展性、更好的隔离性。 缺点 会使代码变得比原来的更加复杂一些。 使用场景： 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项： 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 现实案例 java.util.Calendar#getInstance() java.util.ResourceBundle#getBundle() java.text.NumberFormat#getInstance() java.nio.charset.Charset#forName() java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (Returns different singleton objects, depending on a protocol) java.util.EnumSet#of() javax.xml.bind.JAXBContext#createMarshaller() and other similar methods. 相关模式 Factory Method Factory Kit Abstract Factory","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Introduce(模式简介)","slug":"introduce","date":"2021-05-29T01:00:17.000Z","updated":"2021-05-29T15:17:21.265Z","comments":true,"path":"2021/05/29/introduce/","link":"","permalink":"https://jack838347563.github.io/blog/2021/05/29/introduce/","excerpt":"设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。","text":"设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。","categories":[],"tags":[]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jack838347563.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"行为型模式","slug":"行为型模式","permalink":"https://jack838347563.github.io/blog/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://jack838347563.github.io/blog/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://jack838347563.github.io/blog/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]}